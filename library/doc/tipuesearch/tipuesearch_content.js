var tipuesearch = {"pages":[{"title":" SCM-EDMF ocean ","text":"SCM-EDMF ocean Single column oceanic model (SCM) with Eddy-Diffusion/Mass-Flux (EDMF) closure Developer Info M. Perrot / F. Lemarié","tags":"home","loc":"index.html"},{"title":"Ent_R10 – SCM-EDMF ocean","text":"public  function Ent_R10(beta1, wpp, wpm) Entrainment Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: beta1 parameter of the MF scheme for the entrainment zone real(kind=8), intent(in) :: wpp real(kind=8), intent(in) :: wpm Return Value real(kind=8)","tags":"","loc":"proc/ent_r10.html"},{"title":"Det_R10 – SCM-EDMF ocean","text":"public  function Det_R10(beta1, beta2, wpp, wpm, delta0, hk) Uses scm_par Detrainment The minimum detrainment ensures that as soon as Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: beta1 parameter of the MF scheme for the entrainment zone real(kind=8), intent(in) :: beta2 parameter of the MF scheme for the detrainment zone real(kind=8), intent(in) :: wpp real(kind=8), intent(in) :: wpm real(kind=8), intent(in) :: delta0 background detrainment [m-1] real(kind=8), intent(in) :: hk Thickness ( h_k /) of layer k Return Value real(kind=8)","tags":"","loc":"proc/det_r10.html"},{"title":"Ent_P09 – SCM-EDMF ocean","text":"public  function Ent_P09(cent, Bp) Entrainment Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: cent parameter of the MF scheme for the entrainment zone real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] Return Value real(kind=8)","tags":"","loc":"proc/ent_p09.html"},{"title":"Det_P09 – SCM-EDMF ocean","text":"public  function Det_P09(cdel, wpp, wpm, delta0, Bp) Uses scm_par Detrainment Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: cdel parameter of the MF scheme in the detrainment zone real(kind=8), intent(in) :: wpp [m/s] real(kind=8), intent(in) :: wpm [m/s] real(kind=8), intent(in) :: delta0 background detrainment [m-1] real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] Return Value real(kind=8)","tags":"","loc":"proc/det_p09.html"},{"title":"compute_MF_bdy – SCM-EDMF ocean","text":"public  subroutine compute_MF_bdy(u_m, v_m, t_m, tke, Hz, ntra, npts, wp0, up0, vp0, tp0) Uses scm_par ========================================================================== ***  ROUTINE compute_MF_bdy  *** ** Purposes : compute top initial condition for mass flux equation ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_m (1:npts) mean zonal velocity [m/s] real(kind=8), intent(in) :: v_m (1:npts) mean meridional velocity [m/s] real(kind=8), intent(in) :: t_m (1:npts,1:ntra) mean tracers real(kind=8), intent(in) :: tke (1:npts) turbulent kinetic energy [m2/s2] real(kind=8), intent(in) :: Hz (1:npts) layer thickness [m] integer, intent(in) :: ntra number of tracers integer, intent(in) :: npts number of points used for extrapolation real(kind=8), intent(out) :: wp0 vertical plume velocity at the surface [m/s] real(kind=8), intent(out) :: up0 zonal plume velocity at the surface [m/s] real(kind=8), intent(out) :: vp0 meridional plume velocity at the surface [m/s] real(kind=8), intent(out) :: tp0 (1:ntra+1) tracer plume properties","tags":"","loc":"proc/compute_mf_bdy.html"},{"title":"compute_MF_forcing – SCM-EDMF ocean","text":"public  subroutine compute_MF_forcing(u_np1, v_np1, t_np1, tke, N, ntra, u_m, v_m, t_m, dtke_m) ========================================================================== ***  ROUTINE compute_MF_forcing  *** ** Purposes : compute mean quantities used to force the MF equations ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_np1 (1:N) zonal velocity [m/s] real(kind=8), intent(in) :: v_np1 (1:N) meridional velocity [m/s] real(kind=8), intent(in) :: t_np1 (1:N,ntra) tracers real(kind=8), intent(in) :: tke (0:N) turbulent kinetic energy [m/s] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers real(kind=8), intent(out) :: u_m (1:N) mean zonal velocity for mass-flux equations [m/s] real(kind=8), intent(out) :: v_m (1:N) mean meridional velocity for mass-flux equations [m/s] real(kind=8), intent(out) :: t_m (1:N,ntra+1) mean tracer for mass-flux equations [m/s] real(kind=8), intent(out) :: dtke_m (1:N) mean tracer for mass-flux equations [m/s]","tags":"","loc":"proc/compute_mf_forcing.html"},{"title":"compute_tripleCorr – SCM-EDMF ocean","text":"public  subroutine compute_tripleCorr(tke, tke_p, Fmass, u_p, v_p, w_p, u_np1, v_np1, Hz, zr, wtke, N, trplCorr, tke_env) Uses scm_par ========================================================================== ***  ROUTINE compute_tripleCorr  *** ** Purposes : compute contribution of MF terms to turbulent flux w'e ========================================================================== Note Computation of environmental TKE for diagnostics is missing Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: tke (0:N) mean turbulent kinetic energy [m/s] real(kind=8), intent(in) :: tke_p (0:N) plume turbulent kinetic energy [m/s] real(kind=8), intent(in) :: Fmass (0:N) mass flux [m/s] real(kind=8), intent(in) :: u_p (0:N) plume zonal velocity [m/s] real(kind=8), intent(in) :: v_p (0:N) plume meridional velocity [m/s] real(kind=8), intent(in) :: w_p (0:N) plume vertical velocity [m/s] real(kind=8), intent(in) :: u_np1 (1:N) mean zonal velocity [m/s] real(kind=8), intent(in) :: v_np1 (1:N) mean meridional velocity [m/s] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: zr (1:N) depth of cell centers [m] real(kind=8), intent(inout) :: wtke (1:N) turbulent w'e flux [m3/s3] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: trplCorr (0:N) contribution of mass flux to divergence of w'e flux [m2/s3] real(kind=8), intent(out) :: tke_env (0:N) diagnostics : environmental TKE [m2/s2]","tags":"","loc":"proc/compute_triplecorr.html"},{"title":"eos_val_lin – SCM-EDMF ocean","text":"public  subroutine eos_val_lin(temp, salt, alpha, beta, rho) Uses scm_par ========================================================================== ***  ROUTINE eos_val_lin  *** ** Purposes : compute density anomaly from linear equation of state ========================================================================== Note Reference values and are hardcoded !! Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp temperature [C] real(kind=8), intent(in) :: salt salinity [psu] real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: beta haline expension coefficient [psu-1] real(kind=8), intent(inout) :: rho density anomaly","tags":"","loc":"proc/eos_val_lin.html"},{"title":"eos_val – SCM-EDMF ocean","text":"public  subroutine eos_val(temp, salt, zr, rho) Uses scm_par ========================================================================== ***  ROUTINE rho_eos  *** ** Purposes : Compute density anomaly and Brunt Vaisala frequency via nonlinear\n                                                  Equation Of State (EOS) ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp temperature [C] real(kind=8), intent(in) :: salt salinity [psu] real(kind=8), intent(in) :: zr depth [m] real(kind=8), intent(inout) :: rho density anomaly [kg/m3]","tags":"","loc":"proc/eos_val.html"},{"title":"get_w_p_R10 – SCM-EDMF ocean","text":"public  subroutine get_w_p_R10(wpm, wpp, aa, bb, bpr, beta1, Hz, Bp, h, found) Uses scm_par ========================================================================== ***  ROUTINE get_w_p_R10  *** ** Purposes : compute plume vertical velocity for Rio et al. (2010)\n                        entrainment/detrainement closure ========================================================================== if , otherwise if , otherwise Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: aa parameter of the MF scheme real(kind=8), intent(in) :: bb parameter of the MF scheme real(kind=8), intent(in) :: bpr parameter of the MF scheme real(kind=8), intent(in) :: beta1 parameter of the MF scheme real(kind=8), intent(in) :: Hz thickness of the grid cell [m] real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] real(kind=8), intent(inout) :: h distance from the top of the grid cell where w_p = w_p_min [m] logical, intent(inout) :: found (=T) the bottom of the plume is reached","tags":"","loc":"proc/get_w_p_r10.html"},{"title":"get_a_p_R10 – SCM-EDMF ocean","text":"public  subroutine get_a_p_R10(apm, app, wpm, wpp, beta1, beta2, hk, delta0) Uses scm_par ========================================================================== ***  ROUTINE get_a_p_R10  *** ** Purposes : compute plume fractional area for Rio et al. (2010)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: apm fractional area at the bottom of the grid cell real(kind=8), intent(in) :: app fractional area at the top   of the grid cell real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: beta1 parameter of the MF scheme for the entrainment zone real(kind=8), intent(in) :: beta2 parameter of the MF scheme for the detrainment zone real(kind=8), intent(in) :: hk thickness of the grid cell [m] real(kind=8), intent(in) :: delta0 background detrainement in the entrainment zone [m-1]","tags":"","loc":"proc/get_a_p_r10.html"},{"title":"get_t_p_R10 – SCM-EDMF ocean","text":"public  subroutine get_t_p_R10(tpm, tpp, te, apm, app, wpm, wpp, beta1, beta2, hk, delta0) Uses scm_par ========================================================================== ***  ROUTINE get_t_p_R10  *** ** Purposes : compute plume tracer properties for Rio et al. (2010)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: tpm tracer value at the bottom of the grid cell real(kind=8), intent(in) :: tpp tracer value at the top   of the grid cell real(kind=8), intent(in) :: te environmental value for tracer in the grid cell real(kind=8), intent(in) :: apm fractional area at the bottom of the grid cell real(kind=8), intent(in) :: app fractional area at the top   of the grid cell real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: beta1 parameter of the MF scheme real(kind=8), intent(in) :: beta2 increase the detrainement coefficient beta1 [m-1] real(kind=8), intent(in) :: hk thickness of the grid cell [m] real(kind=8), intent(in) :: delta0 background detrainement in the entrainment zone [m-1]","tags":"","loc":"proc/get_t_p_r10.html"},{"title":"get_dtke_p_R10 – SCM-EDMF ocean","text":"public  subroutine get_dtke_p_R10(tkep_m, tkep_p, dtke_m, normvel, wpm, wpp, hk, epsilon, beta1) Uses scm_par ========================================================================== ***  ROUTINE get_dtke_p_R10  *** ** Purposes : compute plume TKE for Rio et al. (2010)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: tkep_m plume TKE value at the bottom of the grid cell real(kind=8), intent(in) :: tkep_p plume TKE value at the top   of the grid cell real(kind=8), intent(in) :: dtke_m external forcing for the plume TKE real(kind=8), intent(in) :: normvel [m2/s-2] real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: hk thickness of the grid cell [m] real(kind=8), intent(in) :: epsilon plume TKE dissipation term [m2/s-3] real(kind=8), intent(in) :: beta1 parameter of the MF scheme","tags":"","loc":"proc/get_dtke_p_r10.html"},{"title":"get_a_p_P09 – SCM-EDMF ocean","text":"public  subroutine get_a_p_P09(apm, app, wpm, wpp, Hz, Bp, delta0, cent, cdel) ========================================================================== ***  ROUTINE get_w_p_P09  *** ** Purposes : compute plume vertical velocity for Pergaud et al. (2009)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: apm fractional area at the bottom of the grid cell real(kind=8), intent(in) :: app fractional area at the top   of the grid cell real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: Hz thickness of the grid cell [m] real(kind=8), intent(inout) :: Bp plume buoyancy forcing term [m/s2] real(kind=8), intent(in) :: delta0 background detrainement in the entrainment zone [m-1] real(kind=8), intent(in) :: cent parameter of the MF scheme real(kind=8), intent(in) :: cdel parameter of the MF scheme","tags":"","loc":"proc/get_a_p_p09.html"},{"title":"get_t_p_P09 – SCM-EDMF ocean","text":"public  subroutine get_t_p_P09(tpm, tpp, te, apm, app, wpm, wpp, Hz, Bp, delta0, cent, cdel) ========================================================================== ***  ROUTINE get_t_p_P09  *** ** Purposes : compute plume tracer properties for Pergaud et al. (2009)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: tpm tracer value at the bottom of the grid cell real(kind=8), intent(in) :: tpp tracer value at the top   of the grid cell real(kind=8), intent(in) :: te environmental value for tracer in the grid cell real(kind=8), intent(in) :: apm fractional area at the bottom of the grid cell real(kind=8), intent(in) :: app fractional area at the top   of the grid cell real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: Hz thickness of the grid cell [m] real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] real(kind=8), intent(in) :: delta0 background detrainement in the entrainment zone [m-1] real(kind=8), intent(in) :: cent parameter of the MF scheme real(kind=8), intent(in) :: cdel parameter of the MF scheme","tags":"","loc":"proc/get_t_p_p09.html"},{"title":"get_w_p_P09 – SCM-EDMF ocean","text":"public  subroutine get_w_p_P09(wpm, wpp, aa, bb, bpr, cent, Hz, Bp, h, found) Uses scm_par ========================================================================== ***  ROUTINE get_w_p_P09  *** ** Purposes : compute plume vertical velocity for Pergaud et al. (2009)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: aa parameter of the MF scheme real(kind=8), intent(in) :: bb parameter of the MF scheme real(kind=8), intent(in) :: bpr parameter of the MF scheme real(kind=8), intent(in) :: cent parameter of the MF scheme real(kind=8), intent(in) :: Hz thickness of the grid cell [m] real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] real(kind=8), intent(inout) :: h distance from the top of the grid cell where w_p = w_p_min [m] logical, intent(inout) :: found (=T) the bottom of the plume is reached","tags":"","loc":"proc/get_w_p_p09.html"},{"title":"mass_flux_P09 – SCM-EDMF ocean","text":"public  subroutine mass_flux_P09(u_m, v_m, t_m, z_w, Hz, tp0, up0, vp0, wp0, mf_params, alpha, beta, small_ap, zinv, N, ntra, nparams, a_p, u_p, v_p, w_p, t_p, B_p, ent, det) Uses scm_par ========================================================================== ***  ROUTINE mass_flux_P09  *** ** Purposes : solve mass-flux equations for Pergaud et al. (2009)\n                        entrainment/detrainement closure ========================================================================== Compute Compute Compute Compute environment Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_m (1:N) mean zonal velocity [m/s] real(kind=8), intent(in) :: v_m (1:N) mean meridional velocity [m/s] real(kind=8), intent(in) :: t_m (1:N,ntra) mean tracer real(kind=8), intent(in) :: z_w (0:N) depth at cell interfaces [m] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: tp0 (1:ntra) surface value for plume tracers real(kind=8), intent(in) :: up0 surface value for plume zonal velocity [m/s] real(kind=8), intent(in) :: vp0 surface value for plume meridional velocity [m/s] real(kind=8), intent(in) :: wp0 surface value for plume vertical velocity [m/s] real(kind=8), intent(in) :: mf_params (1:nparams) parameters in the ODEs real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: beta haline expension coefficient [psu-1] logical, intent(in) :: small_ap (T) small area approximation (F) no approximation real(kind=8), intent(inout) :: zinv depth at which w_p = wmin  [m] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers integer, intent(in) :: nparams number of parameters in the EDOs real(kind=8), intent(out) :: a_p (0:N) fractional area occupied by the plume real(kind=8), intent(out) :: u_p (0:N) zonal velocity in the plume [m/s] real(kind=8), intent(out) :: v_p (0:N) meridional velocity in the plume [m/s] real(kind=8), intent(out) :: w_p (0:N) vertical velocity in the plume [m/s] real(kind=8), intent(out) :: t_p (0:N,ntra) tracer values in the plume real(kind=8), intent(out) :: B_p (0:N) buoyancy forcing  [m/s2] real(kind=8), intent(out) :: ent (1:N) diagnostics : entrainment [m-1] real(kind=8), intent(out) :: det (1:N) diagnostics : detrainment [m-1]","tags":"","loc":"proc/mass_flux_p09.html"},{"title":"mass_flux_R10 – SCM-EDMF ocean","text":"public  subroutine mass_flux_R10(u_m, v_m, t_m, tke_m, z_w, Hz, tp0, up0, vp0, wp0, mf_params, alpha, beta, small_ap, lin_eos, zinv, N, ntra, nparams, a_p, u_p, v_p, w_p, t_p, B_p, ent, det, eps) Uses scm_par ========================================================================== ***  ROUTINE mass_flux_R10  *** ** Purposes : solve mass-flux equations for Rio et al. (2010)\n                        entrainment/detrainement closure Note we must have and otherwise unphysical values of are obtained ========================================================================== Compute If Compute :: call Compute :: call Compute environment Compute :: call Compute :: call Compute :: call Compute :: call Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_m (1:N) mean zonal velocity [m/s] real(kind=8), intent(in) :: v_m (1:N) mean meridional velocity [m/s] real(kind=8), intent(in) :: t_m (1:N,ntra) mean tracer real(kind=8), intent(in) :: tke_m (0:N) mean TKE [m2/s2] real(kind=8), intent(in) :: z_w (0:N) depth at cell interfaces [m] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: tp0 (1:ntra) surface value for plume tracers real(kind=8), intent(in) :: up0 surface value for plume zonal velocity [m/s] real(kind=8), intent(in) :: vp0 surface value for plume meridional velocity [m/s] real(kind=8), intent(in) :: wp0 surface value for plume vertical velocity [m/s] real(kind=8), intent(in) :: mf_params (1:nparams) parameters in the ODEs real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: beta haline expension coefficient [psu-1] logical, intent(in) :: small_ap (T) small area approximation (F) no approximation logical, intent(in) :: lin_eos real(kind=8), intent(inout) :: zinv depth at which w_p = wmin  [m] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers integer, intent(in) :: nparams number of parameters in the EDOs real(kind=8), intent(out) :: a_p (0:N) fractional area occupied by the plume real(kind=8), intent(out) :: u_p (0:N) zonal velocity in the plume [m/s] real(kind=8), intent(out) :: v_p (0:N) meridional velocity in the plume [m/s] real(kind=8), intent(out) :: w_p (0:N) vertical velocity in the plume [m/s] real(kind=8), intent(out) :: t_p (0:N,ntra) tracer values in the plume real(kind=8), intent(out) :: B_p (0:N) buoyancy forcing  [m/s2] real(kind=8), intent(out) :: ent (1:N) diagnostics : entrainment [m-1] real(kind=8), intent(out) :: det (1:N) diagnostics : detrainment [m-1] real(kind=8), intent(out) :: eps (1:N) diagnostics : TKE dissipation [m2 s-3]","tags":"","loc":"proc/mass_flux_r10.html"},{"title":"advance_tra_ED – SCM-EDMF ocean","text":"public  subroutine advance_tra_ED(t_n, stflx, srflx, swr_frac, Hz, Akt, zw, eps, alpha, dt, N, ntra, t_np1) Uses scm_par ============================================================================ ***  ROUTINE advance_tra_ED  *** ** Purposes : integrate vertical diffusion term for tracers ============================================================================ 1 - Compute fluxes associated to solar penetration and surface bdy condition 2 - Implicit integration for vertical diffusion Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: t_n (1:N,ntra) tracer at time step n real(kind=8), intent(in) :: stflx (ntra) surface tracer fluxes real(kind=8), intent(in) :: srflx surface radiative flux [W/m2] real(kind=8), intent(in) :: swr_frac (0:N) fraction of solar penetration real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: Akt (0:N) eddy-diffusivity [m2/s] real(kind=8), intent(in) :: zw (0:N) depth at cell interfaces [m] real(kind=8), intent(in) :: eps (0:N) TKE dissipation [m2/s3] real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: dt time-step [s] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers to integrate real(kind=8), intent(out) :: t_np1 (1:N,ntra) tracer at time step n+1","tags":"","loc":"proc/advance_tra_ed.html"},{"title":"advance_tra_MF – SCM-EDMF ocean","text":"public  subroutine advance_tra_MF(t_np1, t_p, Fmass, Hz, dt, N, ntra) Uses scm_par ============================================================================ ***  ROUTINE advance_tra_MF  *** ** Purposes : integrate mass flux term for tracers ============================================================================ Compute fluxes associated to mass flux Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: t_np1 (1:N,ntra) tracer at time step n+1 real(kind=8), intent(in) :: t_p (0:N,ntra+1) tracer properties in the plume real(kind=8), intent(in) :: Fmass (0:N) mass flux [m/s] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: dt time-step [s] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers to integrate","tags":"","loc":"proc/advance_tra_mf.html"},{"title":"advance_dyn_MF – SCM-EDMF ocean","text":"public  subroutine advance_dyn_MF(u_np1, v_np1, shear2_MF, u_n, v_n, u_p, v_p, Fmass, Hz, dt, N) Uses scm_par ========================================================================== ***  ROUTINE advance_dyn_MF  *** ** Purposes : integrate mass flux term for dynamics and compute transfer\n                         of KE to TKE related to the mass flux ========================================================================== Compute the shear term associated with mass flux Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: u_np1 (1:N) u-velocity component at time n+1 [m/s] real(kind=8), intent(inout) :: v_np1 (1:N) v-velocity component at time n+1 [m/s] real(kind=8), intent(inout) :: shear2_MF (0:N) TKE production term associated to mass flux [m2/s3] real(kind=8), intent(in) :: u_n (1:N) u-velocity component at time n [m/s] real(kind=8), intent(in) :: v_n (1:N) v-velocity component at time n [m/s] real(kind=8), intent(in) :: u_p (0:N) u-velocity component in the plume [m/s] real(kind=8), intent(in) :: v_p (0:N) v-velocity component in the plume [m/s] real(kind=8), intent(in) :: Fmass (0:N) mass flux [m/s] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: dt time-step [s] integer, intent(in) :: N number of vertical levels","tags":"","loc":"proc/advance_dyn_mf.html"},{"title":"advance_dyn_Cor_ED – SCM-EDMF ocean","text":"public  subroutine advance_dyn_Cor_ED(u_n, v_n, sustr, svstr, Hz, Akv, fcor, dt, nn, N, u_np1, v_np1) ============================================================================ ***  ROUTINE advance_dyn_Cor_ED  *** ** Purposes : integrate vertical viscosity and Coriolis terms for dynamics ============================================================================ 1- Compute Coriolis term if n is even if n is odd 2 - Apply surface forcing 3 - Implicit integration for vertical viscosity Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_n (1:N) u-velocity component at time n [m/s] real(kind=8), intent(in) :: v_n (1:N) v-velocity component at time n [m/s] real(kind=8), intent(in) :: sustr zonal surface stress      [m2/s2] real(kind=8), intent(in) :: svstr meridional surface stress [m2/s2] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(in) :: fcor Coriolis frequaency [s-1] real(kind=8), intent(in) :: dt time-step [s] integer, intent(in) :: nn index for alternating Coriolis integration integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: u_np1 (1:N) u-velocity component at time n+1 [m/s] real(kind=8), intent(out) :: v_np1 (1:N) v-velocity component at time n+1 [m/s]","tags":"","loc":"proc/advance_dyn_cor_ed.html"},{"title":"compute_evd – SCM-EDMF ocean","text":"public  subroutine compute_evd(bvf, Akv, Akt, AkEvd, N) ========================================================================== ***  ROUTINE compute_evd  *** ** Purposes : compute enhanced vertical diffusion/viscosity\n                                   where the density profile is unstable ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequency [s-2] real(kind=8), intent(inout) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(inout) :: Akt (0:N) eddy-diffusivity [m2/s] real(kind=8), intent(in) :: AkEvd value of enhanced diffusion [m2/s] integer, intent(in) :: N number of vertical levels","tags":"","loc":"proc/compute_evd.html"},{"title":"lmd_swfrac – SCM-EDMF ocean","text":"public  subroutine lmd_swfrac(Hz, N, swr_frac) ========================================================================== ***  ROUTINE lmd_swfrac  *** ** Purposes : Compute fraction of solar shortwave flux penetrating to specified\n                depth due to exponential decay in Jerlov water type. ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: swr_frac (0:N) fraction of solar penetration","tags":"","loc":"proc/lmd_swfrac.html"},{"title":"compute_mxl – SCM-EDMF ocean","text":"public  subroutine compute_mxl(bvf, rhoc10, rhoc300, zr, N, hmxl10, hmxl300) Uses scm_par Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequancy [s-2] real(kind=8), intent(in) :: rhoc10 thermal expension coefficient [kg m-3] real(kind=8), intent(in) :: rhoc300 thermal expension coefficient [kg m-3] real(kind=8), intent(in) :: zr (1:N) depth at cell center [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: hmxl10 mixed layer depth [m] real(kind=8), intent(out) :: hmxl300 mixed layer depth [m]","tags":"","loc":"proc/compute_mxl.html"},{"title":"compute_mxl2 – SCM-EDMF ocean","text":"public  subroutine compute_mxl2(bvf, rhoc, zr, zref, N, hmxl) Uses scm_par Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequancy [s-2] real(kind=8), intent(in) :: rhoc thermal expension coefficient [kg m-3] real(kind=8), intent(in) :: zr (1:N) depth at cell center [m] real(kind=8), intent(in) :: zref integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: hmxl mixed layer depth [m]","tags":"","loc":"proc/compute_mxl2.html"},{"title":"rho_eos_lin – SCM-EDMF ocean","text":"public  subroutine rho_eos_lin(temp, salt, zr, alpha, beta, N, rho, bvf) Uses scm_par ========================================================================== ***  ROUTINE rho_eos_lin  *** ** Purposes : Compute density anomaly and Brunt Vaisala frequency via linear\n                                                  Equation Of State (EOS) ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp (1:N) temperature [C] real(kind=8), intent(in) :: salt (1:N) salinity [psu] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: beta haline expension coefficient [psu-1] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: rho (1:N) density anomaly [kg/m3] real(kind=8), intent(out) :: bvf (0:N) Brunt Vaisala frequancy [s-2]","tags":"","loc":"proc/rho_eos_lin.html"},{"title":"rho_eos – SCM-EDMF ocean","text":"public  subroutine rho_eos(temp, salt, zr, zw, N, rho, bvf) Uses scm_par ========================================================================== ***  ROUTINE rho_eos  *** ** Purposes : Compute density anomaly and Brunt Vaisala frequency via nonlinear\n                                                  Equation Of State (EOS) ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp (1:N) temperature [C] real(kind=8), intent(in) :: salt (1:N) salinity [psu] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] real(kind=8), intent(in) :: zw (0:N) depth at cell interfaces [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: rho (1:N) density anomaly [kg/m3] real(kind=8), intent(out) :: bvf (0:N) Brunt Vaisala frequancy [s-2]","tags":"","loc":"proc/rho_eos.html"},{"title":"rho_eos2 – SCM-EDMF ocean","text":"public  subroutine rho_eos2(temp, salt, zr, N, rho) Uses scm_par ========================================================================== ***  ROUTINE rho_eos  *** ** Purposes : Compute density anomaly and Brunt Vaisala frequency via nonlinear\n                                                  Equation Of State (EOS) ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp (1:N) temperature [C] real(kind=8), intent(in) :: salt (1:N) salinity [psu] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: rho (1:N) density anomaly [kg/m3]","tags":"","loc":"proc/rho_eos2.html"},{"title":"tridiag_solve – SCM-EDMF ocean","text":"public  subroutine tridiag_solve(N, Hz, Ak, Fmass, r_D, f, dt) ============================================================================ ***  ROUTINE tridiag_solve  *** ** Purposes : solve the tridiagonal problem associated with the implicit\n                         in time treatment of vertical diffusion/viscosity ============================================================================ Arguments Type Intent Optional Attributes Name integer, intent(in) :: N number of vertical levels real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: Ak (0:N) eddy diffusivity/viscosity [m2/s] real(kind=8), intent(in) :: Fmass (0:N) mass flux (in case of an implicit treatment of MF terms) [m/s] real(kind=8), intent(in) :: r_D bottom friction multiplied by bottom velocity (not used yet) [m/s] real(kind=8), intent(inout) :: f (1:N) (in: right-hand side) (out:solution of tridiagonal problem) real(kind=8), intent(in) :: dt time-step [s]","tags":"","loc":"proc/tridiag_solve.html"},{"title":"compute_tke_bdy – SCM-EDMF ocean","text":"public  subroutine compute_tke_bdy(taux, tauy, tke_const, tke_sfc, tke_bot, flux_sfc) Uses scm_par ========================================================================== ***  ROUTINE compute_tke_bdy  *** ** Purposes : compute top and bottom boundary conditions for TKE equation ========================================================================== free convection case ( ) : wind_cooling case ( ) : bottom boundary condition : Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: taux zonal surface stress      [m2/s2] real(kind=8), intent(in) :: tauy meridional surface stress [m2/s2] integer, intent(in) :: tke_const choice of TKE constants real(kind=8), intent(out) :: tke_sfc surface value for Dirichlet condition [m2/s2] real(kind=8), intent(out) :: tke_bot bottom value for Dirichlet condition [m2/s2] real(kind=8), intent(out) :: flux_sfc surface TKE flux for Neumann condition [m3/s3]","tags":"","loc":"proc/compute_tke_bdy.html"},{"title":"compute_shear – SCM-EDMF ocean","text":"public  subroutine compute_shear(u_n, v_n, u_np1, v_np1, Akv, zr, N, shear2) ========================================================================== ***  ROUTINE compute_shear  *** ** Purposes : compute shear production term for TKE equation ========================================================================== Shear production term using discretization from Burchard (2002) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_n (1:N) velocity components at time n    [m/s] real(kind=8), intent(in) :: v_n (1:N) velocity components at time n    [m/s] real(kind=8), intent(in) :: u_np1 (1:N) velocity components at time n+1  [m/s] real(kind=8), intent(in) :: v_np1 (1:N) velocity components at time n+1  [m/s] real(kind=8), intent(in) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: shear2 (0:N) shear production term [m2/s3]","tags":"","loc":"proc/compute_shear.html"},{"title":"advance_tke – SCM-EDMF ocean","text":"public  subroutine advance_tke(tke_n, lup, ldwn, Akv, Akt, Hz, zr, bvf, buoyMF, shear2, shear2MF, trpl_corrMF, wtke, dt, tke_sfc, tke_bot, flux_sfc, dirichlet_bdy_sfc, tke_const, N, tke_np1, pdlr, eps, residual) Uses scm_par ========================================================================== ***  ROUTINE advance_tke  *** ** Purposes : tke time stepping, advance tke from time step n to n+1 ========================================================================== Dissipative mixing length : Inverse Prandtl number function of Richardson number Right-hand-side for tridiagonal problem Boundary conditions : Solve the tridiagonal problem Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: tke_n (0:N) TKE at time n    [m2/s2] real(kind=8), intent(in) :: lup (0:N) upward mixing length [m] real(kind=8), intent(in) :: ldwn (0:N) downward mixing length [m] real(kind=8), intent(in) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(in) :: Akt (0:N) eddy-diffusion [m2/s] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequency [s-2] real(kind=8), intent(in) :: buoyMF (0:N) TKE buoyancy forcing term associated with mass flux [m2/s3] real(kind=8), intent(in) :: shear2 (0:N) shear tke production term [m2/s3] real(kind=8), intent(in) :: shear2MF (0:N) TKE shear forcing term associated with mass flux [m2/s3] real(kind=8), intent(in) :: trpl_corrMF (0:N) Contribution of mass flux to d(w'e)/dz term [m2/s3] real(kind=8), intent(inout) :: wtke (1:N) Diagnostics : w'e term  [m3/s3] real(kind=8), intent(in) :: dt time-step [s] real(kind=8), intent(in) :: tke_sfc surface boundary condition for TKE [m2/s2] real(kind=8), intent(in) :: tke_bot bottom boundary condition for TKE [m2/s2] real(kind=8), intent(in) :: flux_sfc surface TKE flux [m3/s3] logical, intent(in) :: dirichlet_bdy_sfc Nature of the TKE surface boundary condition (T:dirichlet,F:Neumann) integer, intent(in) :: tke_const choice of TKE constants integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: tke_np1 (0:N) TKE at time n+1    [m2/s2] real(kind=8), intent(out) :: pdlr (0:N) inverse of turbulent Prandtl number real(kind=8), intent(out) :: eps (0:N) TKE dissipation term [m2/s3] real(kind=8), intent(out) :: residual Diagnostics : TKE spuriously added to guarantee that tke >= tke_min [m3/s3]","tags":"","loc":"proc/advance_tke.html"},{"title":"compute_mxl – SCM-EDMF ocean","text":"public  subroutine compute_mxl(tke, bvf, Hz, taux, tauy, N, lup, ldwn) Uses scm_par ============================================================================ ***  ROUTINE compute_mxl  *** ** Purposes : compute mixing length scales ============================================================================ Buoyancy length scale : Physical limits for the mixing lengths Limit such that the bottom boundary condition is Limit such that the surface boundary condition is Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: tke (0:N) turbulent kinetic energy [m2/s2] real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequency [s-2] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: taux surface stress [m2/s2] real(kind=8), intent(in) :: tauy surface stress [m2/s2] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: lup (0:N) upward mixing length [m] real(kind=8), intent(out) :: ldwn (0:N) downward mixing length [m]","tags":"","loc":"proc/compute_mxl~2.html"},{"title":"compute_ED – SCM-EDMF ocean","text":"public  subroutine compute_ED(tke, lup, ldwn, pdlr, extrap_sfc, tke_const, N, Akv, Akt) Uses scm_par ============================================================================ ***  ROUTINE compute_ED  *** ** Purposes : compute the vertical eddy viscosity and diffusivity ============================================================================ Compute \"master\" mixing length Compute eddy-viscosity Compute eddy-diffusivity if Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: tke (0:N) turbulent kinetic energy [m2/s2] real(kind=8), intent(in) :: lup (0:N) upward mixing length [m] real(kind=8), intent(in) :: ldwn (0:N) downward mixing length [m] real(kind=8), intent(in) :: pdlr (0:N) inverse turbulent Prandtl number logical, intent(in) :: extrap_sfc (T) extrapolate eddy coefficients to the surface integer, intent(in) :: tke_const choice of TKE constants integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(out) :: Akt (0:N) eddy-diffusivity [m2/s]","tags":"","loc":"proc/compute_ed.html"},{"title":"tridiag_solve_tke – SCM-EDMF ocean","text":"public  subroutine tridiag_solve_tke(N, Hz, Ak, zr, eps, f, dt, dirichlet_bdy_sfc) ============================================================================ ***  ROUTINE tridiag_solve_tke  *** ** Purposes : solve the tridiagonal problem associated with the implicit\n                                         in time treatment of TKE equation ============================================================================ Arguments Type Intent Optional Attributes Name integer, intent(in) :: N number of vertical levels real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: Ak (0:N) eddy-diffusivity for TKE [m2/s] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] real(kind=8), intent(in) :: eps (0:N) TKE dissipation term divided by TKE [s-1] real(kind=8), intent(inout) :: f (0:N) (in) rhs for tridiagonal problem (out) solution of the tridiagonal problem real(kind=8), intent(in) :: dt time step [s] logical, intent(in) :: dirichlet_bdy_sfc nature of the TKE boundary condition","tags":"","loc":"proc/tridiag_solve_tke.html"},{"title":"scm_mfc – SCM-EDMF ocean","text":"============================================================================ ***  MODULE  scm_mfc  *** Mass-flux (MF) convection scheme for oceanic deep convection ============================================================================ -------------------------------------------------------------------------- compute_MF_bdy    : top boundary conditions for plume properties compute_MF_forcing: compute mean quantities used to force the MF equations compute_tripleCorr: compute contribution of MF terms to turbulent flux w'e eos_val_lin   : linear equation of state get_w_p_R10   : compute plume vertical velocity for Rio et al. 2010 closure get_a_p_R10   : compute plume fractional area for Rio et al. 2010 closure get_t_p_R10   : compute plume tracer properties for Rio et al. 2010 closure get_w_p_P09   : compute plume vertical velocity for Pergaud et al. 2009 closure get_a_p_P09   : compute plume fractional area for Pergaud et al. 2009 closure get_t_p_P09   : compute plume tracer properties for Pergaud et al. 2009 closure mass_flux_R10 : computation of mass-flux and plume properties for Rio et al. 2010 closure mass_flux_P09 : computation of mass-flux and plume properties for Pergaud et al. 2009 closure ---------------------------------------------------------------------------- Functions public  function Ent_R10 (beta1, wpp, wpm) Entrainment Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: beta1 parameter of the MF scheme for the entrainment zone real(kind=8), intent(in) :: wpp real(kind=8), intent(in) :: wpm Return Value real(kind=8) public  function Det_R10 (beta1, beta2, wpp, wpm, delta0, hk) Detrainment The minimum detrainment ensures that as soon as Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: beta1 parameter of the MF scheme for the entrainment zone real(kind=8), intent(in) :: beta2 parameter of the MF scheme for the detrainment zone real(kind=8), intent(in) :: wpp real(kind=8), intent(in) :: wpm real(kind=8), intent(in) :: delta0 background detrainment [m-1] real(kind=8), intent(in) :: hk Thickness ( h_k /) of layer k Return Value real(kind=8) public  function Ent_P09 (cent, Bp) Entrainment Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: cent parameter of the MF scheme for the entrainment zone real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] Return Value real(kind=8) public  function Det_P09 (cdel, wpp, wpm, delta0, Bp) Detrainment Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: cdel parameter of the MF scheme in the detrainment zone real(kind=8), intent(in) :: wpp [m/s] real(kind=8), intent(in) :: wpm [m/s] real(kind=8), intent(in) :: delta0 background detrainment [m-1] real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] Return Value real(kind=8) Subroutines public  subroutine compute_MF_bdy (u_m, v_m, t_m, tke, Hz, ntra, npts, wp0, up0, vp0, tp0) ========================================================================== ***  ROUTINE compute_MF_bdy  *** ** Purposes : compute top initial condition for mass flux equation ========================================================================== Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_m (1:npts) mean zonal velocity [m/s] real(kind=8), intent(in) :: v_m (1:npts) mean meridional velocity [m/s] real(kind=8), intent(in) :: t_m (1:npts,1:ntra) mean tracers real(kind=8), intent(in) :: tke (1:npts) turbulent kinetic energy [m2/s2] real(kind=8), intent(in) :: Hz (1:npts) layer thickness [m] integer, intent(in) :: ntra number of tracers integer, intent(in) :: npts number of points used for extrapolation real(kind=8), intent(out) :: wp0 vertical plume velocity at the surface [m/s] real(kind=8), intent(out) :: up0 zonal plume velocity at the surface [m/s] real(kind=8), intent(out) :: vp0 meridional plume velocity at the surface [m/s] real(kind=8), intent(out) :: tp0 (1:ntra+1) tracer plume properties public  subroutine compute_MF_forcing (u_np1, v_np1, t_np1, tke, N, ntra, u_m, v_m, t_m, dtke_m) ========================================================================== ***  ROUTINE compute_MF_forcing  *** ** Purposes : compute mean quantities used to force the MF equations ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_np1 (1:N) zonal velocity [m/s] real(kind=8), intent(in) :: v_np1 (1:N) meridional velocity [m/s] real(kind=8), intent(in) :: t_np1 (1:N,ntra) tracers real(kind=8), intent(in) :: tke (0:N) turbulent kinetic energy [m/s] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers real(kind=8), intent(out) :: u_m (1:N) mean zonal velocity for mass-flux equations [m/s] real(kind=8), intent(out) :: v_m (1:N) mean meridional velocity for mass-flux equations [m/s] real(kind=8), intent(out) :: t_m (1:N,ntra+1) mean tracer for mass-flux equations [m/s] real(kind=8), intent(out) :: dtke_m (1:N) mean tracer for mass-flux equations [m/s] public  subroutine compute_tripleCorr (tke, tke_p, Fmass, u_p, v_p, w_p, u_np1, v_np1, Hz, zr, wtke, N, trplCorr, tke_env) ========================================================================== ***  ROUTINE compute_tripleCorr  *** ** Purposes : compute contribution of MF terms to turbulent flux w'e ========================================================================== Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: tke (0:N) mean turbulent kinetic energy [m/s] real(kind=8), intent(in) :: tke_p (0:N) plume turbulent kinetic energy [m/s] real(kind=8), intent(in) :: Fmass (0:N) mass flux [m/s] real(kind=8), intent(in) :: u_p (0:N) plume zonal velocity [m/s] real(kind=8), intent(in) :: v_p (0:N) plume meridional velocity [m/s] real(kind=8), intent(in) :: w_p (0:N) plume vertical velocity [m/s] real(kind=8), intent(in) :: u_np1 (1:N) mean zonal velocity [m/s] real(kind=8), intent(in) :: v_np1 (1:N) mean meridional velocity [m/s] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: zr (1:N) depth of cell centers [m] real(kind=8), intent(inout) :: wtke (1:N) turbulent w'e flux [m3/s3] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: trplCorr (0:N) contribution of mass flux to divergence of w'e flux [m2/s3] real(kind=8), intent(out) :: tke_env (0:N) diagnostics : environmental TKE [m2/s2] public  subroutine eos_val_lin (temp, salt, alpha, beta, rho) ========================================================================== ***  ROUTINE eos_val_lin  *** ** Purposes : compute density anomaly from linear equation of state ========================================================================== Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp temperature [C] real(kind=8), intent(in) :: salt salinity [psu] real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: beta haline expension coefficient [psu-1] real(kind=8), intent(inout) :: rho density anomaly public  subroutine eos_val (temp, salt, zr, rho) ========================================================================== ***  ROUTINE rho_eos  *** ** Purposes : Compute density anomaly and Brunt Vaisala frequency via nonlinear\n                                                  Equation Of State (EOS) ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp temperature [C] real(kind=8), intent(in) :: salt salinity [psu] real(kind=8), intent(in) :: zr depth [m] real(kind=8), intent(inout) :: rho density anomaly [kg/m3] public  subroutine get_w_p_R10 (wpm, wpp, aa, bb, bpr, beta1, Hz, Bp, h, found) ========================================================================== ***  ROUTINE get_w_p_R10  *** ** Purposes : compute plume vertical velocity for Rio et al. (2010)\n                        entrainment/detrainement closure ========================================================================== if , otherwise Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: aa parameter of the MF scheme real(kind=8), intent(in) :: bb parameter of the MF scheme real(kind=8), intent(in) :: bpr parameter of the MF scheme real(kind=8), intent(in) :: beta1 parameter of the MF scheme real(kind=8), intent(in) :: Hz thickness of the grid cell [m] real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] real(kind=8), intent(inout) :: h distance from the top of the grid cell where w_p = w_p_min [m] logical, intent(inout) :: found (=T) the bottom of the plume is reached public  subroutine get_a_p_R10 (apm, app, wpm, wpp, beta1, beta2, hk, delta0) ========================================================================== ***  ROUTINE get_a_p_R10  *** ** Purposes : compute plume fractional area for Rio et al. (2010)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: apm fractional area at the bottom of the grid cell real(kind=8), intent(in) :: app fractional area at the top   of the grid cell real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: beta1 parameter of the MF scheme for the entrainment zone real(kind=8), intent(in) :: beta2 parameter of the MF scheme for the detrainment zone real(kind=8), intent(in) :: hk thickness of the grid cell [m] real(kind=8), intent(in) :: delta0 background detrainement in the entrainment zone [m-1] public  subroutine get_t_p_R10 (tpm, tpp, te, apm, app, wpm, wpp, beta1, beta2, hk, delta0) ========================================================================== ***  ROUTINE get_t_p_R10  *** ** Purposes : compute plume tracer properties for Rio et al. (2010)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: tpm tracer value at the bottom of the grid cell real(kind=8), intent(in) :: tpp tracer value at the top   of the grid cell real(kind=8), intent(in) :: te environmental value for tracer in the grid cell real(kind=8), intent(in) :: apm fractional area at the bottom of the grid cell real(kind=8), intent(in) :: app fractional area at the top   of the grid cell real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: beta1 parameter of the MF scheme real(kind=8), intent(in) :: beta2 increase the detrainement coefficient beta1 [m-1] real(kind=8), intent(in) :: hk thickness of the grid cell [m] real(kind=8), intent(in) :: delta0 background detrainement in the entrainment zone [m-1] public  subroutine get_dtke_p_R10 (tkep_m, tkep_p, dtke_m, normvel, wpm, wpp, hk, epsilon, beta1) ========================================================================== ***  ROUTINE get_dtke_p_R10  *** ** Purposes : compute plume TKE for Rio et al. (2010)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: tkep_m plume TKE value at the bottom of the grid cell real(kind=8), intent(in) :: tkep_p plume TKE value at the top   of the grid cell real(kind=8), intent(in) :: dtke_m external forcing for the plume TKE real(kind=8), intent(in) :: normvel [m2/s-2] real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: hk thickness of the grid cell [m] real(kind=8), intent(in) :: epsilon plume TKE dissipation term [m2/s-3] real(kind=8), intent(in) :: beta1 parameter of the MF scheme public  subroutine get_a_p_P09 (apm, app, wpm, wpp, Hz, Bp, delta0, cent, cdel) ========================================================================== ***  ROUTINE get_w_p_P09  *** ** Purposes : compute plume vertical velocity for Pergaud et al. (2009)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: apm fractional area at the bottom of the grid cell real(kind=8), intent(in) :: app fractional area at the top   of the grid cell real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: Hz thickness of the grid cell [m] real(kind=8), intent(inout) :: Bp plume buoyancy forcing term [m/s2] real(kind=8), intent(in) :: delta0 background detrainement in the entrainment zone [m-1] real(kind=8), intent(in) :: cent parameter of the MF scheme real(kind=8), intent(in) :: cdel parameter of the MF scheme public  subroutine get_t_p_P09 (tpm, tpp, te, apm, app, wpm, wpp, Hz, Bp, delta0, cent, cdel) ========================================================================== ***  ROUTINE get_t_p_P09  *** ** Purposes : compute plume tracer properties for Pergaud et al. (2009)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: tpm tracer value at the bottom of the grid cell real(kind=8), intent(in) :: tpp tracer value at the top   of the grid cell real(kind=8), intent(in) :: te environmental value for tracer in the grid cell real(kind=8), intent(in) :: apm fractional area at the bottom of the grid cell real(kind=8), intent(in) :: app fractional area at the top   of the grid cell real(kind=8), intent(in) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: Hz thickness of the grid cell [m] real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] real(kind=8), intent(in) :: delta0 background detrainement in the entrainment zone [m-1] real(kind=8), intent(in) :: cent parameter of the MF scheme real(kind=8), intent(in) :: cdel parameter of the MF scheme public  subroutine get_w_p_P09 (wpm, wpp, aa, bb, bpr, cent, Hz, Bp, h, found) ========================================================================== ***  ROUTINE get_w_p_P09  *** ** Purposes : compute plume vertical velocity for Pergaud et al. (2009)\n                        entrainment/detrainement closure ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: wpm vertical velocity at the bottom of the grid cell [m/s] real(kind=8), intent(in) :: wpp vertical velocity at the top of the grid cell [m/s] real(kind=8), intent(in) :: aa parameter of the MF scheme real(kind=8), intent(in) :: bb parameter of the MF scheme real(kind=8), intent(in) :: bpr parameter of the MF scheme real(kind=8), intent(in) :: cent parameter of the MF scheme real(kind=8), intent(in) :: Hz thickness of the grid cell [m] real(kind=8), intent(in) :: Bp plume buoyancy forcing term [m/s2] real(kind=8), intent(inout) :: h distance from the top of the grid cell where w_p = w_p_min [m] logical, intent(inout) :: found (=T) the bottom of the plume is reached public  subroutine mass_flux_P09 (u_m, v_m, t_m, z_w, Hz, tp0, up0, vp0, wp0, mf_params, alpha, beta, small_ap, zinv, N, ntra, nparams, a_p, u_p, v_p, w_p, t_p, B_p, ent, det) ========================================================================== ***  ROUTINE mass_flux_P09  *** ** Purposes : solve mass-flux equations for Pergaud et al. (2009)\n                        entrainment/detrainement closure ========================================================================== Compute Compute Compute Compute environment Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_m (1:N) mean zonal velocity [m/s] real(kind=8), intent(in) :: v_m (1:N) mean meridional velocity [m/s] real(kind=8), intent(in) :: t_m (1:N,ntra) mean tracer real(kind=8), intent(in) :: z_w (0:N) depth at cell interfaces [m] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: tp0 (1:ntra) surface value for plume tracers real(kind=8), intent(in) :: up0 surface value for plume zonal velocity [m/s] real(kind=8), intent(in) :: vp0 surface value for plume meridional velocity [m/s] real(kind=8), intent(in) :: wp0 surface value for plume vertical velocity [m/s] real(kind=8), intent(in) :: mf_params (1:nparams) parameters in the ODEs real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: beta haline expension coefficient [psu-1] logical, intent(in) :: small_ap (T) small area approximation (F) no approximation real(kind=8), intent(inout) :: zinv depth at which w_p = wmin  [m] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers integer, intent(in) :: nparams number of parameters in the EDOs real(kind=8), intent(out) :: a_p (0:N) fractional area occupied by the plume real(kind=8), intent(out) :: u_p (0:N) zonal velocity in the plume [m/s] real(kind=8), intent(out) :: v_p (0:N) meridional velocity in the plume [m/s] real(kind=8), intent(out) :: w_p (0:N) vertical velocity in the plume [m/s] real(kind=8), intent(out) :: t_p (0:N,ntra) tracer values in the plume real(kind=8), intent(out) :: B_p (0:N) buoyancy forcing  [m/s2] real(kind=8), intent(out) :: ent (1:N) diagnostics : entrainment [m-1] real(kind=8), intent(out) :: det (1:N) diagnostics : detrainment [m-1] public  subroutine mass_flux_R10 (u_m, v_m, t_m, tke_m, z_w, Hz, tp0, up0, vp0, wp0, mf_params, alpha, beta, small_ap, lin_eos, zinv, N, ntra, nparams, a_p, u_p, v_p, w_p, t_p, B_p, ent, det, eps) ========================================================================== ***  ROUTINE mass_flux_R10  *** ** Purposes : solve mass-flux equations for Rio et al. (2010)\n                        entrainment/detrainement closure Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_m (1:N) mean zonal velocity [m/s] real(kind=8), intent(in) :: v_m (1:N) mean meridional velocity [m/s] real(kind=8), intent(in) :: t_m (1:N,ntra) mean tracer real(kind=8), intent(in) :: tke_m (0:N) mean TKE [m2/s2] real(kind=8), intent(in) :: z_w (0:N) depth at cell interfaces [m] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: tp0 (1:ntra) surface value for plume tracers real(kind=8), intent(in) :: up0 surface value for plume zonal velocity [m/s] real(kind=8), intent(in) :: vp0 surface value for plume meridional velocity [m/s] real(kind=8), intent(in) :: wp0 surface value for plume vertical velocity [m/s] real(kind=8), intent(in) :: mf_params (1:nparams) parameters in the ODEs real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: beta haline expension coefficient [psu-1] logical, intent(in) :: small_ap (T) small area approximation (F) no approximation logical, intent(in) :: lin_eos real(kind=8), intent(inout) :: zinv depth at which w_p = wmin  [m] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers integer, intent(in) :: nparams number of parameters in the EDOs real(kind=8), intent(out) :: a_p (0:N) fractional area occupied by the plume real(kind=8), intent(out) :: u_p (0:N) zonal velocity in the plume [m/s] real(kind=8), intent(out) :: v_p (0:N) meridional velocity in the plume [m/s] real(kind=8), intent(out) :: w_p (0:N) vertical velocity in the plume [m/s] real(kind=8), intent(out) :: t_p (0:N,ntra) tracer values in the plume real(kind=8), intent(out) :: B_p (0:N) buoyancy forcing  [m/s2] real(kind=8), intent(out) :: ent (1:N) diagnostics : entrainment [m-1] real(kind=8), intent(out) :: det (1:N) diagnostics : detrainment [m-1] real(kind=8), intent(out) :: eps (1:N) diagnostics : TKE dissipation [m2 s-3]","tags":"","loc":"module/scm_mfc.html"},{"title":"scm_oce – SCM-EDMF ocean","text":"============================================================================ ***  MODULE  scm_oce  *** Single Column Model (SCM) time-stepping and oceanic equation of state ============================================================================ ---------------------------------------------------------------------------- advance_tra_ED     : integrate eddy-diffusion term for tracers advance_tra_MF     : integrate mass-flux term for tracers advance_dyn_MF     : integrate mass-flux term for dynamics advance_dyn_Cor_ED : integrate eddy-viscosity and Coriolis terms for dynamics compute_evd        : compute Enhanced Vertical Diffusion (EVD) lmd_swfrac         : compute fraction of solar penetration rho_eos_lin        : linear equation of state tridiag_solve      : tridiagonal solver ---------------------------------------------------------------------------- Subroutines public  subroutine advance_tra_ED (t_n, stflx, srflx, swr_frac, Hz, Akt, zw, eps, alpha, dt, N, ntra, t_np1) ============================================================================ ***  ROUTINE advance_tra_ED  *** ** Purposes : integrate vertical diffusion term for tracers ============================================================================ 1 - Compute fluxes associated to solar penetration and surface bdy condition Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: t_n (1:N,ntra) tracer at time step n real(kind=8), intent(in) :: stflx (ntra) surface tracer fluxes real(kind=8), intent(in) :: srflx surface radiative flux [W/m2] real(kind=8), intent(in) :: swr_frac (0:N) fraction of solar penetration real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: Akt (0:N) eddy-diffusivity [m2/s] real(kind=8), intent(in) :: zw (0:N) depth at cell interfaces [m] real(kind=8), intent(in) :: eps (0:N) TKE dissipation [m2/s3] real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: dt time-step [s] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers to integrate real(kind=8), intent(out) :: t_np1 (1:N,ntra) tracer at time step n+1 public  subroutine advance_tra_MF (t_np1, t_p, Fmass, Hz, dt, N, ntra) ============================================================================ ***  ROUTINE advance_tra_MF  *** ** Purposes : integrate mass flux term for tracers ============================================================================ Compute fluxes associated to mass flux Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: t_np1 (1:N,ntra) tracer at time step n+1 real(kind=8), intent(in) :: t_p (0:N,ntra+1) tracer properties in the plume real(kind=8), intent(in) :: Fmass (0:N) mass flux [m/s] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: dt time-step [s] integer, intent(in) :: N number of vertical levels integer, intent(in) :: ntra number of tracers to integrate public  subroutine advance_dyn_MF (u_np1, v_np1, shear2_MF, u_n, v_n, u_p, v_p, Fmass, Hz, dt, N) ========================================================================== ***  ROUTINE advance_dyn_MF  *** ** Purposes : integrate mass flux term for dynamics and compute transfer\n                         of KE to TKE related to the mass flux ========================================================================== Compute the shear term associated with mass flux Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout) :: u_np1 (1:N) u-velocity component at time n+1 [m/s] real(kind=8), intent(inout) :: v_np1 (1:N) v-velocity component at time n+1 [m/s] real(kind=8), intent(inout) :: shear2_MF (0:N) TKE production term associated to mass flux [m2/s3] real(kind=8), intent(in) :: u_n (1:N) u-velocity component at time n [m/s] real(kind=8), intent(in) :: v_n (1:N) v-velocity component at time n [m/s] real(kind=8), intent(in) :: u_p (0:N) u-velocity component in the plume [m/s] real(kind=8), intent(in) :: v_p (0:N) v-velocity component in the plume [m/s] real(kind=8), intent(in) :: Fmass (0:N) mass flux [m/s] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: dt time-step [s] integer, intent(in) :: N number of vertical levels public  subroutine advance_dyn_Cor_ED (u_n, v_n, sustr, svstr, Hz, Akv, fcor, dt, nn, N, u_np1, v_np1) ============================================================================ ***  ROUTINE advance_dyn_Cor_ED  *** ** Purposes : integrate vertical viscosity and Coriolis terms for dynamics ============================================================================ 1- Compute Coriolis term if n is even if n is odd 2 - Apply surface forcing 3 - Implicit integration for vertical viscosity Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_n (1:N) u-velocity component at time n [m/s] real(kind=8), intent(in) :: v_n (1:N) v-velocity component at time n [m/s] real(kind=8), intent(in) :: sustr zonal surface stress      [m2/s2] real(kind=8), intent(in) :: svstr meridional surface stress [m2/s2] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(in) :: fcor Coriolis frequaency [s-1] real(kind=8), intent(in) :: dt time-step [s] integer, intent(in) :: nn index for alternating Coriolis integration integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: u_np1 (1:N) u-velocity component at time n+1 [m/s] real(kind=8), intent(out) :: v_np1 (1:N) v-velocity component at time n+1 [m/s] public  subroutine compute_evd (bvf, Akv, Akt, AkEvd, N) ========================================================================== ***  ROUTINE compute_evd  *** ** Purposes : compute enhanced vertical diffusion/viscosity\n                                   where the density profile is unstable ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequency [s-2] real(kind=8), intent(inout) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(inout) :: Akt (0:N) eddy-diffusivity [m2/s] real(kind=8), intent(in) :: AkEvd value of enhanced diffusion [m2/s] integer, intent(in) :: N number of vertical levels public  subroutine lmd_swfrac (Hz, N, swr_frac) ========================================================================== ***  ROUTINE lmd_swfrac  *** ** Purposes : Compute fraction of solar shortwave flux penetrating to specified\n                depth due to exponential decay in Jerlov water type. ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: swr_frac (0:N) fraction of solar penetration public  subroutine compute_mxl (bvf, rhoc10, rhoc300, zr, N, hmxl10, hmxl300) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequancy [s-2] real(kind=8), intent(in) :: rhoc10 thermal expension coefficient [kg m-3] real(kind=8), intent(in) :: rhoc300 thermal expension coefficient [kg m-3] real(kind=8), intent(in) :: zr (1:N) depth at cell center [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: hmxl10 mixed layer depth [m] real(kind=8), intent(out) :: hmxl300 mixed layer depth [m] public  subroutine compute_mxl2 (bvf, rhoc, zr, zref, N, hmxl) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequancy [s-2] real(kind=8), intent(in) :: rhoc thermal expension coefficient [kg m-3] real(kind=8), intent(in) :: zr (1:N) depth at cell center [m] real(kind=8), intent(in) :: zref integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: hmxl mixed layer depth [m] public  subroutine rho_eos_lin (temp, salt, zr, alpha, beta, N, rho, bvf) ========================================================================== ***  ROUTINE rho_eos_lin  *** ** Purposes : Compute density anomaly and Brunt Vaisala frequency via linear\n                                                  Equation Of State (EOS) ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp (1:N) temperature [C] real(kind=8), intent(in) :: salt (1:N) salinity [psu] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] real(kind=8), intent(in) :: alpha thermal expension coefficient [C-1] real(kind=8), intent(in) :: beta haline expension coefficient [psu-1] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: rho (1:N) density anomaly [kg/m3] real(kind=8), intent(out) :: bvf (0:N) Brunt Vaisala frequancy [s-2] public  subroutine rho_eos (temp, salt, zr, zw, N, rho, bvf) ========================================================================== ***  ROUTINE rho_eos  *** ** Purposes : Compute density anomaly and Brunt Vaisala frequency via nonlinear\n                                                  Equation Of State (EOS) ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp (1:N) temperature [C] real(kind=8), intent(in) :: salt (1:N) salinity [psu] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] real(kind=8), intent(in) :: zw (0:N) depth at cell interfaces [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: rho (1:N) density anomaly [kg/m3] real(kind=8), intent(out) :: bvf (0:N) Brunt Vaisala frequancy [s-2] public  subroutine rho_eos2 (temp, salt, zr, N, rho) ========================================================================== ***  ROUTINE rho_eos  *** ** Purposes : Compute density anomaly and Brunt Vaisala frequency via nonlinear\n                                                  Equation Of State (EOS) ========================================================================== Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: temp (1:N) temperature [C] real(kind=8), intent(in) :: salt (1:N) salinity [psu] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: rho (1:N) density anomaly [kg/m3] public  subroutine tridiag_solve (N, Hz, Ak, Fmass, r_D, f, dt) ============================================================================ ***  ROUTINE tridiag_solve  *** ** Purposes : solve the tridiagonal problem associated with the implicit\n                         in time treatment of vertical diffusion/viscosity ============================================================================ Arguments Type Intent Optional Attributes Name integer, intent(in) :: N number of vertical levels real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: Ak (0:N) eddy diffusivity/viscosity [m2/s] real(kind=8), intent(in) :: Fmass (0:N) mass flux (in case of an implicit treatment of MF terms) [m/s] real(kind=8), intent(in) :: r_D bottom friction multiplied by bottom velocity (not used yet) [m/s] real(kind=8), intent(inout) :: f (1:N) (in: right-hand side) (out:solution of tridiagonal problem) real(kind=8), intent(in) :: dt time-step [s]","tags":"","loc":"module/scm_oce.html"},{"title":"scm_tke – SCM-EDMF ocean","text":"============================================================================ ***  MODULE  scm_tke  *** Eddy-diffusion closure: TKE scheme with diagnostic mixing lengths\n                         adapted from NEMO TKE turbulent closure model ============================================================================ ---------------------------------------------------------------------------- compute_tke_bdy   : top and bottom boundary conditions for TKE compute_shear     : compute shear production term advance_tke       : tke time stepping: advance tke at next time step compute_mxl       : compute mixing length scale compute_ED        : compute avm and avt tridiag_solve_tke : tridiagonal solver for TKE equation ---------------------------------------------------------------------------- Subroutines public  subroutine compute_tke_bdy (taux, tauy, tke_const, tke_sfc, tke_bot, flux_sfc) ========================================================================== ***  ROUTINE compute_tke_bdy  *** ** Purposes : compute top and bottom boundary conditions for TKE equation ========================================================================== free convection case ( ) : wind_cooling case ( ) : bottom boundary condition : Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: taux zonal surface stress      [m2/s2] real(kind=8), intent(in) :: tauy meridional surface stress [m2/s2] integer, intent(in) :: tke_const choice of TKE constants real(kind=8), intent(out) :: tke_sfc surface value for Dirichlet condition [m2/s2] real(kind=8), intent(out) :: tke_bot bottom value for Dirichlet condition [m2/s2] real(kind=8), intent(out) :: flux_sfc surface TKE flux for Neumann condition [m3/s3] public  subroutine compute_shear (u_n, v_n, u_np1, v_np1, Akv, zr, N, shear2) ========================================================================== ***  ROUTINE compute_shear  *** ** Purposes : compute shear production term for TKE equation ========================================================================== Shear production term using discretization from Burchard (2002) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: u_n (1:N) velocity components at time n    [m/s] real(kind=8), intent(in) :: v_n (1:N) velocity components at time n    [m/s] real(kind=8), intent(in) :: u_np1 (1:N) velocity components at time n+1  [m/s] real(kind=8), intent(in) :: v_np1 (1:N) velocity components at time n+1  [m/s] real(kind=8), intent(in) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: shear2 (0:N) shear production term [m2/s3] public  subroutine advance_tke (tke_n, lup, ldwn, Akv, Akt, Hz, zr, bvf, buoyMF, shear2, shear2MF, trpl_corrMF, wtke, dt, tke_sfc, tke_bot, flux_sfc, dirichlet_bdy_sfc, tke_const, N, tke_np1, pdlr, eps, residual) ========================================================================== ***  ROUTINE advance_tke  *** ** Purposes : tke time stepping, advance tke from time step n to n+1 ========================================================================== Dissipative mixing length : Inverse Prandtl number function of Richardson number Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: tke_n (0:N) TKE at time n    [m2/s2] real(kind=8), intent(in) :: lup (0:N) upward mixing length [m] real(kind=8), intent(in) :: ldwn (0:N) downward mixing length [m] real(kind=8), intent(in) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(in) :: Akt (0:N) eddy-diffusion [m2/s] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequency [s-2] real(kind=8), intent(in) :: buoyMF (0:N) TKE buoyancy forcing term associated with mass flux [m2/s3] real(kind=8), intent(in) :: shear2 (0:N) shear tke production term [m2/s3] real(kind=8), intent(in) :: shear2MF (0:N) TKE shear forcing term associated with mass flux [m2/s3] real(kind=8), intent(in) :: trpl_corrMF (0:N) Contribution of mass flux to d(w'e)/dz term [m2/s3] real(kind=8), intent(inout) :: wtke (1:N) Diagnostics : w'e term  [m3/s3] real(kind=8), intent(in) :: dt time-step [s] real(kind=8), intent(in) :: tke_sfc surface boundary condition for TKE [m2/s2] real(kind=8), intent(in) :: tke_bot bottom boundary condition for TKE [m2/s2] real(kind=8), intent(in) :: flux_sfc surface TKE flux [m3/s3] logical, intent(in) :: dirichlet_bdy_sfc Nature of the TKE surface boundary condition (T:dirichlet,F:Neumann) integer, intent(in) :: tke_const choice of TKE constants integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: tke_np1 (0:N) TKE at time n+1    [m2/s2] real(kind=8), intent(out) :: pdlr (0:N) inverse of turbulent Prandtl number real(kind=8), intent(out) :: eps (0:N) TKE dissipation term [m2/s3] real(kind=8), intent(out) :: residual Diagnostics : TKE spuriously added to guarantee that tke >= tke_min [m3/s3] public  subroutine compute_mxl (tke, bvf, Hz, taux, tauy, N, lup, ldwn) ============================================================================ ***  ROUTINE compute_mxl  *** ** Purposes : compute mixing length scales ============================================================================ Read more… Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: tke (0:N) turbulent kinetic energy [m2/s2] real(kind=8), intent(in) :: bvf (0:N) Brunt Vaisala frequency [s-2] real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: taux surface stress [m2/s2] real(kind=8), intent(in) :: tauy surface stress [m2/s2] integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: lup (0:N) upward mixing length [m] real(kind=8), intent(out) :: ldwn (0:N) downward mixing length [m] public  subroutine compute_ED (tke, lup, ldwn, pdlr, extrap_sfc, tke_const, N, Akv, Akt) ============================================================================ ***  ROUTINE compute_ED  *** ** Purposes : compute the vertical eddy viscosity and diffusivity ============================================================================ Compute \"master\" mixing length Compute eddy-viscosity Compute eddy-diffusivity if Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: tke (0:N) turbulent kinetic energy [m2/s2] real(kind=8), intent(in) :: lup (0:N) upward mixing length [m] real(kind=8), intent(in) :: ldwn (0:N) downward mixing length [m] real(kind=8), intent(in) :: pdlr (0:N) inverse turbulent Prandtl number logical, intent(in) :: extrap_sfc (T) extrapolate eddy coefficients to the surface integer, intent(in) :: tke_const choice of TKE constants integer, intent(in) :: N number of vertical levels real(kind=8), intent(out) :: Akv (0:N) eddy-viscosity [m2/s] real(kind=8), intent(out) :: Akt (0:N) eddy-diffusivity [m2/s] public  subroutine tridiag_solve_tke (N, Hz, Ak, zr, eps, f, dt, dirichlet_bdy_sfc) ============================================================================ ***  ROUTINE tridiag_solve_tke  *** ** Purposes : solve the tridiagonal problem associated with the implicit\n                                         in time treatment of TKE equation ============================================================================ Arguments Type Intent Optional Attributes Name integer, intent(in) :: N number of vertical levels real(kind=8), intent(in) :: Hz (1:N) layer thickness [m] real(kind=8), intent(in) :: Ak (0:N) eddy-diffusivity for TKE [m2/s] real(kind=8), intent(in) :: zr (1:N) depth at cell centers [m] real(kind=8), intent(in) :: eps (0:N) TKE dissipation term divided by TKE [s-1] real(kind=8), intent(inout) :: f (0:N) (in) rhs for tridiagonal problem (out) solution of the tridiagonal problem real(kind=8), intent(in) :: dt time step [s] logical, intent(in) :: dirichlet_bdy_sfc nature of the TKE boundary condition","tags":"","loc":"module/scm_tke.html"},{"title":"scm_par – SCM-EDMF ocean","text":"Variables Type Visibility Attributes Name Initial real(kind=8), public, parameter :: grav = 9.81 Gravity of Earth real(kind=8), public, parameter :: vkarmn = 0.41 Von Karman constant real(kind=8), public, parameter :: rho0 = 1027. Boussinesq reference density [kg/m3] real(kind=8), public, parameter :: cp = 3985.0d0 Specific heat capacity of saltwater [J/kg K] real(kind=8), public, parameter :: rpi = 4.*ATAN(1.) real(kind=8), public, parameter :: wpmin = 1.e-08 Minimum value of [m/s] real(kind=8), public, parameter :: tke_min = 1.e-8 minimum TKE value [m2/s2] real(kind=8), public, parameter :: tke_min0 = 1.e-4 surface minimum value of tke for Dirichlet condition [m2/s2] real(kind=8), public, parameter :: avm_bak = 1.e-4 background eddy-viscosity [m2/s] real(kind=8), public, parameter :: avt_bak = 1.e-5 background eddy-diffusivity [m2/s] real(kind=8), public, parameter :: ceps_nemo = 0.5*sqrt(2.) Constant in NEMO real(kind=8), public, parameter :: cm_nemo = 0.1 Constant in NEMO real(kind=8), public, parameter :: ct_nemo = 0.1 Constant in NEMO real(kind=8), public, parameter :: ce_nemo = 0.1 Constant in NEMO real(kind=8), public, parameter :: Ric_nemo = 2./(2.+ceps_nemo/cm_nemo) Critical Richardson number real(kind=8), public, parameter :: ceps_mnh = 0.845 Constant in MesoNH real(kind=8), public, parameter :: cm_mnh = 0.126 Constant in MesoNH real(kind=8), public, parameter :: ct_mnh = 0.143 Constant in MesoNH real(kind=8), public, parameter :: ce_mnh = 0.34 Constant in MesoNH real(kind=8), public, parameter :: Ric_mnh = 0.143 Critical Richardson number real(kind=8), public, parameter :: ceps_r81 = 0.7 Constant in Redelsperger & Sommeria 1981 real(kind=8), public, parameter :: cm_r81 = 0.0667 Constant in Redelsperger & Sommeria 1981 real(kind=8), public, parameter :: ct_r81 = 0.167 Constant in Redelsperger & Sommeria 1981 real(kind=8), public, parameter :: ce_r81 = 0.4 Constant in Redelsperger & Sommeria 1981 real(kind=8), public, parameter :: Ric_r81 = 0.139 Critical Richardson number real(kind=8), public, parameter :: mxl_min = (avm_bak/0.1)/sqrt(tke_min) minimum value for mixing lengths [m] real(kind=8), public, parameter :: mxl_min0 = 0.04 minimum surface value for miwing lengths [m] real(kind=8), public, parameter :: pdlrmin = 0.1 minimum value for the inverse Prandtl number real(kind=8), public, parameter :: bshear = 1.e-20 minimum shear real(kind=8), public, parameter :: rsmall = 1.e-20","tags":"","loc":"module/scm_par.html"},{"title":"scm_mfc.f90 – SCM-EDMF ocean","text":"Source Code MODULE scm_mfc !!============================================================================<br /> !!                       ***  MODULE  scm_mfc  ***                            <br /> !!        Mass-flux (MF) convection scheme for oceanic deep convection        <br /> !!============================================================================<br /> !!--------------------------------------------------------------------------<br /> !!   compute_MF_bdy    : top boundary conditions for plume properties       <br /> !!   compute_MF_forcing: compute mean quantities used to force the MF equations <br /> !!   compute_tripleCorr: compute contribution of MF terms to turbulent flux w'e <br /> !!   eos_val_lin   : linear equation of state                           <br /> !!   get_w_p_R10   : compute plume vertical velocity for Rio et al. 2010 closure <br /> !!   get_a_p_R10   : compute plume fractional area for Rio et al. 2010 closure   <br /> !!   get_t_p_R10   : compute plume tracer properties for Rio et al. 2010 closure <br /> !!   get_w_p_P09   : compute plume vertical velocity for Pergaud et al. 2009 closure <br /> !!   get_a_p_P09   : compute plume fractional area for Pergaud et al. 2009 closure   <br /> !!   get_t_p_P09   : compute plume tracer properties for Pergaud et al. 2009 closure <br /> !!   mass_flux_R10 : computation of mass-flux and plume properties for Rio et al. 2010 closure<br /> !!   mass_flux_P09 : computation of mass-flux and plume properties for Pergaud et al. 2009 closure<br /> !!----------------------------------------------------------------------------<br /> IMPLICIT NONE CONTAINS !=================================================================================================== SUBROUTINE compute_MF_bdy ( u_m , v_m , t_m , tke , Hz , ntra , npts , wp0 , up0 , vp0 , tp0 ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE compute_MF_bdy  ***                        <br /> !! ** Purposes : compute top initial condition for mass flux equation       <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: ntra !! number of tracers INTEGER , INTENT ( IN ) :: npts !! number of points used for extrapolation REAL ( 8 ), INTENT ( IN ) :: tke ( 1 : npts ) !! turbulent kinetic energy [m2/s2] REAL ( 8 ), INTENT ( IN ) :: u_m ( 1 : npts ) !! mean zonal velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: v_m ( 1 : npts ) !! mean meridional velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: t_m ( 1 : npts , 1 : ntra ) !! mean tracers REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : npts ) !! layer thickness [m] REAL ( 8 ), INTENT ( OUT ) :: wp0 !! vertical plume velocity at the surface [m/s] REAL ( 8 ), INTENT ( OUT ) :: up0 !! zonal plume velocity at the surface [m/s] REAL ( 8 ), INTENT ( OUT ) :: vp0 !! meridional plume velocity at the surface [m/s] REAL ( 8 ), INTENT ( OUT ) :: tp0 ( 1 : ntra + 1 ) !! tracer plume properties ! local variables INTEGER :: itrc REAL ( 8 ) :: cff ! wp0 = - wpmin !!  w&#94;{\\rm p}_{\\rm sfc} = - w&#94;{\\rm p}_{\\min} <br /> ! cff = 1. / ( Hz ( npts - 1 ) + Hz ( npts )) DO itrc = 1 , ntra ! temperature & salinity tp0 ( itrc ) = cff * (( 2. * Hz ( npts ) + Hz ( npts - 1 )) * t_m ( npts , itrc ) & - Hz ( npts ) * t_m ( npts - 1 , itrc ) ) !!  \\phi&#94;{\\rm p}_{\\rm sfc} = \\frac{ (2 h_N+h_{N-1}) \\overline{\\phi}_N - h_N \\overline{\\phi}_{N-1} }{h_N + h_{N-1}}  <br /> !tp0 (itrc) = (1.+0.75)*t_m(npts  ,itrc) - 0.75*t_m(npts-1,itrc) ENDDO ! TKE tp0 ( ntra + 1 ) = tke ( npts ) !!  k&#94;{\\rm p}_{\\rm sfc} = k_{N+1/2}  <br /> ! up0 = cff * (( 2. * Hz ( npts ) + Hz ( npts - 1 )) * u_m ( npts ) & - Hz ( npts ) * u_m ( npts - 1 ) ) !!  u&#94;{\\rm p}_{\\rm sfc} = \\frac{ (2 h_N+h_{N-1}) \\overline{u}_N - h_N \\overline{u}_{N-1} }{h_N + h_{N-1}}  <br /> vp0 = cff * (( 2. * Hz ( npts ) + Hz ( npts - 1 )) * v_m ( npts ) & - Hz ( npts ) * v_m ( npts - 1 ) ) !!  v&#94;{\\rm p}_{\\rm sfc} = \\frac{ (2 h_N+h_{N-1}) \\overline{v}_N - h_N \\overline{v}_{N-1} }{h_N + h_{N-1}}  <br /> !--------------------------------------------------------------------------------------------------- END SUBROUTINE compute_MF_bdy !=================================================================================================== !=================================================================================================== SUBROUTINE compute_MF_forcing ( u_np1 , v_np1 , t_np1 , tke , N , ntra , u_m , v_m , t_m , dtke_m ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE compute_MF_forcing  ***                    <br /> !! ** Purposes : compute mean quantities used to force the MF equations     <br /> !!==========================================================================<br /> IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels INTEGER , INTENT ( IN ) :: ntra !! number of tracers REAL ( 8 ), INTENT ( IN ) :: u_np1 ( 1 : N ) !! zonal velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: v_np1 ( 1 : N ) !! meridional velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: t_np1 ( 1 : N , ntra ) !! tracers REAL ( 8 ), INTENT ( IN ) :: tke ( 0 : N ) !! turbulent kinetic energy [m/s] REAL ( 8 ), INTENT ( OUT ) :: u_m ( 1 : N ) !! mean zonal velocity for mass-flux equations [m/s] REAL ( 8 ), INTENT ( OUT ) :: v_m ( 1 : N ) !! mean meridional velocity for mass-flux equations [m/s] REAL ( 8 ), INTENT ( OUT ) :: t_m ( 1 : N , ntra + 1 ) !! mean tracer for mass-flux equations [m/s] REAL ( 8 ), INTENT ( OUT ) :: dtke_m ( 1 : N ) !! mean tracer for mass-flux equations [m/s] ! local variables INTEGER :: k , itrc ! DO itrc = 1 , ntra ! temperature & salinity DO k = 1 , N t_m ( k , itrc ) = t_np1 ( k , itrc ) !!  \\overline{\\phi}_{k} = \\phi&#94;{\\rm scm}_k   <br /> ENDDO ENDDO ! TKE DO k = 1 , N t_m ( k , ntra + 1 ) = 0.5 * ( tke ( k ) + tke ( k - 1 )) !!  k_{k+1/2} = \\frac{1}{2} (k&#94;{\\rm scm}_{k+1/2}+k&#94;{\\rm scm}_{k-1/2})   <br /> dtke_m ( k ) = tke ( k ) - tke ( k - 1 ) ENDDO ! DO k = 1 , N u_m ( k ) = u_np1 ( k ) !!  \\overline{u}_{k} = u&#94;{\\rm scm}_k   <br /> v_m ( k ) = v_np1 ( k ) !!  \\overline{v}_{k} = v&#94;{\\rm scm}_k   <br /> ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE compute_MF_forcing !=================================================================================================== !=================================================================================================== SUBROUTINE compute_tripleCorr ( tke , tke_p , Fmass , u_p , v_p , w_p , u_np1 , v_np1 , Hz , zr , wtke , N , trplCorr , tke_env ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE compute_tripleCorr  ***                    <br /> !! ** Purposes : compute contribution of MF terms to turbulent flux w'e     <br /> !!    \\overline{w'e}_{\\rm MF} = a&#94;{\\rm p} w&#94;{\\rm p} \\underbrace{\\left[ \\frac{1}{1-a&#94;{\\rm p}} \\right]}_{\\rm small\\_ap = False} \\left\\{ \\left(  k&#94;{\\rm p} - k&#94;n \\right) !!    + \\frac{1}{2} \\| \\mathbf{v}&#94;p - \\mathbf{v}&#94;{n+1} \\|&#94;2 \\right\\}       <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: tke ( 0 : N ) !! mean turbulent kinetic energy [m/s] REAL ( 8 ), INTENT ( IN ) :: tke_p ( 0 : N ) !! plume turbulent kinetic energy [m/s] REAL ( 8 ), INTENT ( IN ) :: w_p ( 0 : N ) !! plume vertical velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: Fmass ( 0 : N ) !! mass flux [m/s] REAL ( 8 ), INTENT ( IN ) :: u_p ( 0 : N ) !! plume zonal velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: v_p ( 0 : N ) !! plume meridional velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: u_np1 ( 1 : N ) !! mean zonal velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: v_np1 ( 1 : N ) !! mean meridional velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: zr ( 1 : N ) !! depth of cell centers [m] REAL ( 8 ), INTENT ( INOUT ) :: wtke ( 1 : N ) !! turbulent w'e flux [m3/s3] REAL ( 8 ), INTENT ( OUT ) :: trplCorr ( 0 : N ) !! contribution of mass flux to divergence of w'e flux [m2/s3] REAL ( 8 ), INTENT ( OUT ) :: tke_env ( 0 : N ) !! diagnostics : environmental TKE [m2/s2] ! local variables INTEGER :: k REAL ( 8 ) :: cff , cff1 , cff2 , cff3 REAL ( 8 ) :: FC ( 1 : N ) REAL ( 8 ) :: Fm , wpr , upr , vpr !=============================================================== ! Compute fluxes at rho-points and flux divergence at w-points FC ( 1 : N ) = 0. trplCorr ( 0 : N ) = 0. tke_env ( 0 : N ) = 0. ! DO k = 1 , N - 1 Fm = Fmass ( k ) wpr = w_p ( k ) upr = u_p ( k ) vpr = v_p ( k ) ! FC ( k ) = Fm * ( tke_p ( k ) - tke ( k - 1 ) ) !!  F_{k} = (a&#94;{\\rm p} w&#94;{\\rm p})_{k+1/2} ( k&#94;{\\rm p}_{k+1/2} - k_{k-1/2}&#94;n ) <br /> FC ( k ) = FC ( k ) + 0.5 * Fm * ( & ( upr - u_np1 ( k )) ** 2 & + ( vpr - v_np1 ( k )) ** 2 & + wpr * wpr ) !!  F_{k} = F_{k} + \\frac{(a&#94;{\\rm p} w&#94;{\\rm p})_{k+1/2}}{2}\\left(  \\mathbf{v}&#94;{\\rm p}_{k+1/2} - \\mathbf{v}&#94;{n+1}_{k} \\right)&#94;2   <br /> wtke ( k ) = wtke ( k ) - FC ( k ) ENDDO ! DO k = 1 , N - 1 trplCorr ( k ) = ( FC ( k + 1 ) - FC ( k )) / ( zr ( k + 1 ) - zr ( k )) !!  {\\rm TOM}_{k+1/2} = \\frac{ F_{k+1}-F_{k} }{ \\Delta z_{k+1/2} }    <br /> ENDDO !!@note Computation of environmental TKE for diagnostics is missing @endnote !DO k = 1,N !  upr        = u_p(k) - u_np1(k) !  vpr        = v_p(k) - v_np1(k) !  wpr        = w_p(k) !  tke_env(k) = tke(k) - a_p(k)*( tke_p(k) + wpr*wpr + upr*upr + vpr*vpr ) !ENDDO tke_env ( 0 : N ) = tke_min !--------------------------------------------------------------------------------------------------- END SUBROUTINE compute_tripleCorr !=================================================================================================== !=================================================================================================== SUBROUTINE eos_val_lin ( temp , salt , alpha , beta , rho ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE eos_val_lin  ***                           <br /> !! ** Purposes : compute density anomaly from linear equation of state      <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( IN ) :: temp !! temperature [C] REAL ( 8 ), INTENT ( IN ) :: salt !! salinity [psu] REAL ( 8 ), INTENT ( IN ) :: alpha !! thermal expension coefficient [C-1] REAL ( 8 ), INTENT ( IN ) :: beta !! haline expension coefficient [psu-1] REAL ( 8 ), INTENT ( INOUT ) :: rho !! density anomaly !--------------------------------------------------------------------------------------------------- ! Compute density anomaly via linear Equation Of State (EOS) !------- rho = rho0 * ( 1. - alpha * ( temp - 2. ) + beta * ( salt - 3 5. ) ) !!    \\rho_{k} = \\rho_0 \\left( 1 - \\alpha (\\theta - 2) + \\beta (S - 35)   \\right)    <br /> !!@note Reference values  \\theta_0 = 2&#94;{o}C  and  S_0 = 35\\;{\\rm psu} are hardcoded !!  @endnote <br /> return !--------------------------------------------------------------------------------------------------- END SUBROUTINE eos_val_lin !=================================================================================================== !=================================================================================================== SUBROUTINE eos_val ( temp , salt , zr , rho ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE rho_eos  ***                           <br /> !! ** Purposes : Compute density anomaly and Brunt Vaisala frequency via nonlinear !!                                                  Equation Of State (EOS) <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( IN ) :: temp !! temperature [C] REAL ( 8 ), INTENT ( IN ) :: salt !! salinity [psu] REAL ( 8 ), INTENT ( IN ) :: zr !! depth [m] REAL ( 8 ), INTENT ( INOUT ) :: rho !! density anomaly [kg/m3] ! local variables real ( 8 ) :: cff , cff1 , dr00 , dpth , rho1 real ( 8 ) :: Tt , Ts , sqrtTs , K0 , K1 , K2 ! EOS parameters real ( 8 ) :: r00 , r01 , r02 , r03 , r04 , r05 real ( 8 ) :: r10 , r11 , r12 , r13 , r14 , r20 real ( 8 ) :: rS0 , rS1 , rS2 real ( 8 ) :: K00 , K01 , K02 , K03 , K04 real ( 8 ) :: K10 , K11 , K12 , K13 real ( 8 ) :: KS0 , KS1 , KS2 real ( 8 ) :: B00 , B01 , B02 , B03 , B10 , B11 , B12 , BS1 real ( 8 ) :: E00 , E01 , E02 , E10 , E11 , E12 !--------------------------------------------------------------------------- parameter ( r00 = 99 9.842594 , r01 = 6.793952E-2 , r02 =- 9.095290E-3 , & r03 = 1.001685E-4 , r04 =- 1.120083E-6 , r05 = 6.536332E-9 ) ! parameter ( r10 = 0.824493 , r11 =- 4.08990E-3 , r12 = 7.64380E-5 , & r13 =- 8.24670E-7 , r14 = 5.38750E-9 , r20 = 4.8314E-4 ) parameter ( rS0 =- 5.72466E-3 , rS1 = 1.02270E-4 , rS2 =- 1.65460E-6 ) ! parameter ( K00 = 1909 2.56 , K01 = 20 9.8925 , K02 =- 3.041638 , & K03 =- 1.852732e-3 , K04 =- 1.361629e-5 ) parameter ( K10 = 10 4.4077 , K11 =- 6.500517 , K12 = 0.1553190 , & K13 = 2.326469e-4 ) ! parameter ( KS0 =- 5.587545 , KS1 =+ 0.7390729 , KS2 =- 1.909078e-2 ) ! parameter ( B00 = 0.4721788 , B01 = 0.01028859 , B02 =- 2.512549e-4 , & B03 =- 5.939910e-7 , B10 =- 0.01571896 , B11 =- 2.598241e-4 , & B12 = 7.267926e-6 , BS1 = 2.042967e-3 ) ! parameter ( E00 =+ 1.045941e-5 , E01 =- 5.782165e-10 , E02 =+ 1.296821e-7 , & E10 =- 2.595994e-7 , E11 =- 1.248266e-9 , E12 =- 3.508914e-9 ) !--------------------------------------------------------------------------- dr00 = r00 - rho0 ! Compute density anomaly via Equation Of State (EOS) for seawater Tt = temp Ts = salt sqrtTs = sqrt ( Ts ) ! rho1 = ( dr00 + Tt * ( r01 + Tt * ( r02 + Tt * ( r03 + Tt * ( r04 + Tt * r05 )))) & + Ts * ( r10 + Tt * ( r11 + Tt * ( r12 + Tt * ( r13 + Tt * r14 ))) & + sqrtTs * ( rS0 + Tt * ( rS1 + Tt * rS2 )) + Ts * r20 ) & ) ! K0 = Tt * ( K01 + Tt * ( K02 + Tt * ( K03 + Tt * K04 ))) & + Ts * ( K10 + Tt * ( K11 + Tt * ( K12 + Tt * K13 )) & + sqrtTs * ( KS0 + Tt * ( KS1 + Tt * KS2 )) ) ! K1 = B00 + Tt * ( B01 + Tt * ( B02 + Tt * B03 )) + Ts * ( B10 + Tt * ( B11 + Tt * B12 ) + sqrtTs * BS1 ) ! K2 = E00 + Tt * ( E01 + Tt * E02 ) + Ts * ( E10 + Tt * ( E11 + Tt * E12 )) ! dpth = - zr cff = K00 - 0.1 * dpth cff1 = K0 + dpth * ( K1 + K2 * dpth ) rho = ( rho1 * cff * ( K00 + cff1 ) - 0.1 * dpth * rho0 * cff1 ) / ( cff * ( cff + cff1 )) !--------------------------------------------------------------------------------------------------- END SUBROUTINE eos_val !=================================================================================================== !=================================================================================================== SUBROUTINE get_w_p_R10 ( wpm , wpp , aa , bb , bpr , beta1 , Hz , Bp , h , found ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE get_w_p_R10  ***                           <br /> !! ** Purposes : compute plume vertical velocity for Rio et al. (2010) !!                        entrainment/detrainement closure                  <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( INOUT ) :: wpm !! vertical velocity at the bottom of the grid cell [m/s] REAL ( 8 ), INTENT ( INOUT ) :: h !! distance from the top of the grid cell where w_p = w_p_min [m] LOGICAL , INTENT ( INOUT ) :: found !! (=T) the bottom of the plume is reached REAL ( 8 ), INTENT ( IN ) :: wpp !! vertical velocity at the top of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: Bp !! plume buoyancy forcing term [m/s2] REAL ( 8 ), INTENT ( IN ) :: Hz !! thickness of the grid cell [m] REAL ( 8 ), INTENT ( IN ) :: aa !! parameter of the MF scheme REAL ( 8 ), INTENT ( IN ) :: bb !! parameter of the MF scheme REAL ( 8 ), INTENT ( IN ) :: bpr !! parameter of the MF scheme REAL ( 8 ), INTENT ( IN ) :: beta1 !! parameter of the MF scheme ! local variables REAL ( 8 ) :: cff1 , cff , rhsw , wpm2 ! rhsw = bpr * ( wpp * wpp + wpp * wpp ) + 2 * aa * Bp !!    {\\rm rhs}_{k}&#94;{\\star} = 2 b'( w&#94;{\\rm p}_{k+1/2} )&#94;2 + 2 a B_{k}&#94;{\\rm p}    <br /> cff = 1. ; IF ( rhsw < 0. ) cff = 1. + bb * beta1 !! if  {\\rm rhs}_{k}&#94;{\\star} < 0 \\Rightarrow \\alpha_w = 1 + b \\beta_1 ,  \\alpha_w = 1  otherwise <br /> cff1 = 1. / ( cff + Hz * bpr ) wpm2 = cff1 * ( ( cff - Hz * bpr ) * wpp * wpp - aa * Hz * 2. * Bp ) !!   ( w&#94;{\\rm p}_{k-1/2} )&#94;2 = \\frac{ (\\alpha_w - h_k b') ( w&#94;{\\rm p}_{k+1/2} )&#94;2 - 2 a h_k B_{k}&#94;{\\rm p} }{\\alpha_w + h_k b'} <br /> ! in case the sign of the rhs has changed rhsw = bpr * ( wpp * wpp + wpm2 ) + 2 * aa * Bp !!    {\\rm rhs}_{k} = b'\\left( ( w&#94;{\\rm p}_{k-1/2} )&#94;2 + ( w&#94;{\\rm p}_{k+1/2} )&#94;2 \\right) + 2 a B_{k}&#94;{\\rm p}    <br /> cff = 1. ; IF ( rhsw < 0. ) cff = 1. + bb * beta1 !! if  {\\rm rhs}_{k} < 0 \\Rightarrow \\alpha_w = 1 + b \\beta_1 ,  \\alpha_w = 1  otherwise <br /> cff1 = 1. / ( cff + Hz * bpr ) wpm2 = cff1 * ( ( cff - Hz * bpr ) * wpp * wpp - aa * Hz * 2. * Bp ) !!   ( w&#94;{\\rm p}_{k-1/2} )&#94;2 = \\frac{ (\\alpha_w - h_k b') ( w&#94;{\\rm p}_{k+1/2} )&#94;2 - 2 a h_k B_{k}&#94;{\\rm p} }{\\alpha_w + h_k b'} <br /> ! finalize computation wpm = - SQRT ( MAX ( wpm2 , wpmin * wpmin ) ) ! IF ( cff == 1. ) THEN ! the bottom of the plume is reached only if we are in the detrainment zone h = ( wpp * wpp - wpmin * wpmin ) / & ( 2. * aa * Bp + bpr * ( wpp * wpp + wpmin * wpmin )) IF ( h > 0. . AND . h < Hz ) found = . true . ENDIF return !--------------------------------------------------------------------------------------------------- END SUBROUTINE get_w_p_R10 !=================================================================================================== !=================================================================================================== SUBROUTINE get_a_p_R10 ( apm , app , wpm , wpp , beta1 , beta2 , hk , delta0 ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE get_a_p_R10  ***                           <br /> !! ** Purposes : compute plume fractional area for Rio et al. (2010) !!                        entrainment/detrainement closure                  <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( INOUT ) :: apm !! fractional area at the bottom of the grid cell REAL ( 8 ), INTENT ( IN ) :: app !! fractional area at the top   of the grid cell REAL ( 8 ), INTENT ( IN ) :: wpm !! vertical velocity at the bottom of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: wpp !! vertical velocity at the top of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: beta1 !! parameter of the MF scheme for the entrainment zone REAL ( 8 ), INTENT ( IN ) :: hk !! thickness of the grid cell [m] REAL ( 8 ), INTENT ( IN ) :: delta0 !! background detrainement in the entrainment zone [m-1] REAL ( 8 ), INTENT ( IN ) :: beta2 !! parameter of the MF scheme for the detrainment zone !local variables REAL ( 8 ) :: cff1 , cff , EmD ! EmD = Ent_R10 ( beta1 , wpp , wpm ) + & Det_R10 ( beta1 , beta2 , wpp , wpm , delta0 , hk ) !!    {\\rm EmD}_k = \\frac{h_k}{a&#94;{\\rm p}} \\left( E_k - D_k \\right) = {\\rm Ent\\_R10} + {\\rm Det\\_R10}    <br /> cff = 1. / ( 2. * wpm + EmD ) cff1 = app * ( 2. * wpp - EmD ) apm = cff * cff1 !!   a&#94;{\\rm p}_{k-1/2} = a&#94;{\\rm p}_{k+1/2} \\left(  \\frac{2 w&#94;{\\rm p}_{k+1/2} - {\\rm EmD}_k}{2 w&#94;{\\rm p}_{k-1/2} + {\\rm EmD}_k}   \\right)    <br /> return !--------------------------------------------------------------------------------------------------- END SUBROUTINE get_a_p_R10 !=================================================================================================== REAL ( 8 ) FUNCTION Ent_R10 ( beta1 , wpp , wpm ) !! Entrainment  {\\rm Ent\\_R10} = \\frac{E_k h_k}{a&#94;p} = \\max\\left( \\beta_1(w_{k+1/2}&#94;p-w_{k-1/2}&#94;p), 0 \\right)   IMPLICIT NONE REAL ( 8 ), INTENT ( IN ) :: beta1 !! parameter of the MF scheme for the entrainment zone REAL ( 8 ), INTENT ( IN ) :: wpp !!  w&#94;{\\rm p}_{k+1/2}  REAL ( 8 ), INTENT ( IN ) :: wpm !!  w&#94;{\\rm p}_{k-1/2}  Ent_R10 = MAX ( beta1 * ( wpp - wpm ), 0. ) END FUNCTION Ent_R10 REAL ( 8 ) FUNCTION Det_R10 ( beta1 , beta2 , wpp , wpm , delta0 , hk ) !! Detrainment  {\\rm Det\\_R10} = -\\frac{D_k h_k}{a&#94;p} = \\min\\left( \\beta_2(w_{k+1/2}&#94;p-w_{k-1/2}&#94;p), 0 \\right) + \\min\\left(-2 w&#94;{\\rm p}_{\\min}, h_k \\delta_0 \\frac{w_{k+1/2}&#94;p+w_{k-1/2}&#94;p}{2} \\right)   <br /> !! The minimum detrainment  -2 w&#94;{\\rm p}_{\\min}  ensures that  a&#94;{\\rm p}_{k-1/2} = 0  as soon as  w&#94;{\\rm p}_{k+1/2} = w&#94;{\\rm p}_{k-1/2} = -w&#94;{\\rm p}_{\\min}  USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( IN ) :: beta1 !! parameter of the MF scheme for the entrainment zone REAL ( 8 ), INTENT ( IN ) :: wpp !!  w&#94;{\\rm p}_{k+1/2}  REAL ( 8 ), INTENT ( IN ) :: wpm !!  w&#94;{\\rm p}_{k-1/2}  REAL ( 8 ), INTENT ( IN ) :: delta0 !! background detrainment [m-1] REAL ( 8 ), INTENT ( IN ) :: hk !! Thickness  h_k /) of layer k REAL ( 8 ), INTENT ( IN ) :: beta2 !! parameter of the MF scheme for the detrainment zone REAL ( 8 ) :: D0 , D1 D0 = 0.5 * hk * delta0 * ( wpp + wpm ) Det_R10 = MIN ( beta2 * ( wpp - wpm ), 0. ) & + MIN ( D0 , - 2. * wpmin ) END FUNCTION Det_R10 REAL ( 8 ) FUNCTION Ent_P09 ( cent , Bp ) !! Entrainment  {\\rm Ent\\_P09} = \\frac{E_k w&#94;{\\rm p}}{a&#94;{\\rm p}} = C_\\epsilon \\max\\left( B&#94;{\\rm p}, 0 \\right)   IMPLICIT NONE REAL ( 8 ), INTENT ( IN ) :: cent !! parameter  C_\\epsilon  of the MF scheme for the entrainment zone REAL ( 8 ), INTENT ( IN ) :: Bp !! plume buoyancy forcing term  B&#94;{\\rm p}  [m/s2] Ent_P09 = cent * MIN ( Bp , 0. ) END FUNCTION Ent_P09 REAL ( 8 ) FUNCTION Det_P09 ( cdel , wpp , wpm , delta0 , Bp ) !! Detrainment  {\\rm Det\\_P09} = -\\frac{D_k w&#94;{\\rm p}}{a&#94;{\\rm p}} = (- C_\\delta)\\min\\left( B&#94;{\\rm p}, 0 \\right) + \\delta_0 (w&#94;{\\rm p})&#94;2  USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( IN ) :: cdel !! parameter  C_\\delta  of the MF scheme in the detrainment zone REAL ( 8 ), INTENT ( IN ) :: wpp !!  w&#94;{\\rm p}_{k+1/2}  [m/s] REAL ( 8 ), INTENT ( IN ) :: wpm !!  w&#94;{\\rm p}_{k-1/2}  [m/s] REAL ( 8 ), INTENT ( IN ) :: delta0 !! background detrainment [m-1] REAL ( 8 ), INTENT ( IN ) :: Bp !! plume buoyancy forcing term  B&#94;{\\rm p}  [m/s2] Det_P09 = - cdel * MAX ( Bp , 0. ) + delta0 * 0.5 * ( wpp * wpp + wpm * wpm ) END FUNCTION Det_P09 !=================================================================================================== SUBROUTINE get_t_p_R10 ( tpm , tpp , te , apm , app , wpm , wpp , beta1 , beta2 , hk , delta0 ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE get_t_p_R10  ***                           <br /> !! ** Purposes : compute plume tracer properties for Rio et al. (2010) !!                        entrainment/detrainement closure                  <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( INOUT ) :: tpm !! tracer value at the bottom of the grid cell REAL ( 8 ), INTENT ( IN ) :: tpp !! tracer value at the top   of the grid cell REAL ( 8 ), INTENT ( IN ) :: te !! environmental value for tracer in the grid cell REAL ( 8 ), INTENT ( IN ) :: apm !! fractional area at the bottom of the grid cell REAL ( 8 ), INTENT ( IN ) :: app !! fractional area at the top   of the grid cell REAL ( 8 ), INTENT ( IN ) :: wpm !! vertical velocity at the bottom of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: wpp !! vertical velocity at the top of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: beta1 !! parameter of the MF scheme REAL ( 8 ), INTENT ( IN ) :: hk !! thickness of the grid cell [m] REAL ( 8 ), INTENT ( IN ) :: delta0 !! background detrainement in the entrainment zone [m-1] REAL ( 8 ), INTENT ( IN ) :: beta2 !! increase the detrainement coefficient beta1 [m-1] ! local variables REAL ( 8 ) :: cffm , cffp , dwpm , dwpp , ap , cff ! cffp = app * wpp * tpp !!   \\Phi&#94;{\\rm p}_{k+1/2} = a&#94;{\\rm p}_{k+1/2} w&#94;{\\rm p}_{k+1/2} \\phi&#94;{\\rm p}_{k+1/2}    <br /> ap = 0.5 * ( app + apm ) !!   a&#94;{\\rm p}_{k} = \\frac{a&#94;{\\rm p}_{k+1/2}+a&#94;{\\rm p}_{k-1/2}}{2}    <br /> dwpp = Ent_R10 ( beta1 , wpp , wpm ) dwpm = Det_R10 ( beta1 , beta2 , wpp , wpm , delta0 , hk ) cffm = cffp - ap * ( dwpp * te + dwpm * tpp ) !!  \\Phi&#94;{\\rm p}_{k-1/2} = \\Phi&#94;{\\rm p}_{k+1/2} - a&#94;{\\rm p}_{k} \\left( \\underbrace{\\frac{E_k h_k}{a&#94;p}}_{\\rm Ent\\_R10} \\phi_{k}&#94;{\\rm e} \\underbrace{- \\frac{D_k h_k}{a&#94;p}}_{\\rm Det\\_R10} \\phi_{k+1/2}&#94;{\\rm p}     \\right)     <br /> IF ( apm > 0. ) THEN tpm = cffm / ( apm * wpm ) !!  \\phi&#94;{\\rm p}_{k-1/2} = \\frac{\\Phi&#94;{\\rm p}_{k-1/2}}{( a&#94;{\\rm p} w&#94;{\\rm p} )_{k-1/2}}   <br /> ELSE tpm = tpp ENDIF ! return !--------------------------------------------------------------------------------------------------- END SUBROUTINE get_t_p_R10 !=================================================================================================== !=================================================================================================== SUBROUTINE get_dtke_p_R10 ( tkep_m , tkep_p , dtke_m , normvel , wpm , wpp , hk , epsilon , beta1 ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE get_dtke_p_R10  ***                           <br /> !! ** Purposes : compute plume TKE for Rio et al. (2010) !!                        entrainment/detrainement closure                  <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( INOUT ) :: tkep_m !! plume TKE value at the bottom of the grid cell REAL ( 8 ), INTENT ( IN ) :: tkep_p !! plume TKE value at the top   of the grid cell REAL ( 8 ), INTENT ( IN ) :: dtke_m !! external forcing for the plume TKE REAL ( 8 ), INTENT ( IN ) :: wpm !! vertical velocity at the bottom of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: wpp !! vertical velocity at the top of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: normvel !!  \\| \\mathbf{u}&#94;{\\rm p} - \\mathbf{u} \\|&#94;2   [m2/s-2] REAL ( 8 ), INTENT ( IN ) :: hk !! thickness of the grid cell [m] REAL ( 8 ), INTENT ( IN ) :: epsilon !! plume TKE dissipation term [m2/s-3] REAL ( 8 ), INTENT ( IN ) :: beta1 !! parameter of the MF scheme ! local variables REAL ( 8 ) :: cffm , cffp , dwp , cff , chi ! dwp = MAX ( wpp - wpm , 0. ) !!   (\\delta w&#94;{\\rm p})_{k}&#94;{+} = \\max( w&#94;{\\rm p}_{k+1/2}-w&#94;{\\rm p}_{k-1/2}  ,0)   <br /> cff = 1. / ( wpp + wpm ) chi = cff * beta1 * dwp !!   \\chi_k = \\frac{\\beta_1}{w&#94;{\\rm p}_{k+1/2}+w&#94;{\\rm p}_{k-1/2}} (\\delta w&#94;{\\rm p})_{k}&#94;{+} \\equiv \\frac{E_k h_k}{2 a&#94;{\\rm p} w&#94;{\\rm p}}      <br /> tkep_m = ( ( 1. + chi ) * tkep_p - chi * normvel + dtke_m + 2. * hk * cff * epsilon ) / ( 1. - chi ) !!  (e&#94;{\\rm p}-e)_{k-1/2} = \\frac{(1+\\chi_k)(e&#94;{\\rm p}-e)_{k+1/2} - \\chi_k \\| \\mathbf{u}&#94;{\\rm p} - \\mathbf{u} \\|_k&#94;2 + (e_{k+1/2}-e_{k-1/2}) + \\frac{2 h_k}{w&#94;{\\rm p}_{k+1/2}+w&#94;{\\rm p}_{k-1/2}} \\epsilon_{k+1/2}&#94;{\\rm p}   }{1-\\chi_k}     ! return !--------------------------------------------------------------------------------------------------- END SUBROUTINE get_dtke_p_R10 !=================================================================================================== !=================================================================================================== SUBROUTINE get_a_p_P09 ( apm , app , wpm , wpp , Hz , Bp , delta0 , cent , cdel ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE get_w_p_P09  ***                           <br /> !! ** Purposes : compute plume vertical velocity for Pergaud et al. (2009) !!                        entrainment/detrainement closure                  <br /> !!==========================================================================<br /> IMPLICIT NONE REAL ( 8 ), INTENT ( INOUT ) :: apm !! fractional area at the bottom of the grid cell REAL ( 8 ), INTENT ( INOUT ) :: Bp !! plume buoyancy forcing term [m/s2] REAL ( 8 ), INTENT ( IN ) :: app !! fractional area at the top   of the grid cell REAL ( 8 ), INTENT ( IN ) :: wpm !! vertical velocity at the bottom of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: wpp !! vertical velocity at the top of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: Hz !! thickness of the grid cell [m] REAL ( 8 ), INTENT ( IN ) :: delta0 !! background detrainement in the entrainment zone [m-1] REAL ( 8 ), INTENT ( IN ) :: cent !! parameter of the MF scheme REAL ( 8 ), INTENT ( IN ) :: cdel !! parameter of the MF scheme ! local variables REAL ( 8 ) :: cff1 , cff2 , cff , Bpmax , Bpmin , lim , back ! !lim   = (app*wpp*(wpp+wpm)-1.e-12*wpm*(wpp+wpm))/(app+1.e-12) lim = wpp * ( wpp + wpm ) Bpmax = - lim / ( Hz * cdel ) Bp = MIN ( Bp , Bpmax ) ! lim = ( app * wpp * ( wpp + wpm ) - 0.99 * wpm * ( wpp + wpm )) / ( 0.99 + app ) Bpmin = lim / ( Hz * cent ) Bp = MAX ( Bp , Bpmin ) ! !back  = delta0*0.25*(wpp+wpm)**2/(-cdel) !back  = delta0*0.5*(wpp*wpp+wpm*wpm)/(-cdel) cff = Ent_P09 ( cent , Bp ) + Det_P09 ( cdel , wpp , wpm , delta0 , Bp ) cff1 = app * ( wpp * ( wpp + wpm ) - Hz * cff ) cff2 = 1. / ( wpm * ( wpp + wpm ) + Hz * cff ) apm = cff1 * cff2 return !--------------------------------------------------------------------------------------------------- END SUBROUTINE get_a_p_P09 !=================================================================================================== !=================================================================================================== SUBROUTINE get_t_p_P09 ( tpm , tpp , te , apm , app , wpm , wpp , Hz , Bp , delta0 , cent , cdel ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE get_t_p_P09  ***                           <br /> !! ** Purposes : compute plume tracer properties for Pergaud et al. (2009) !!                        entrainment/detrainement closure                  <br /> !!==========================================================================<br /> IMPLICIT NONE REAL ( 8 ), INTENT ( INOUT ) :: tpm !! tracer value at the bottom of the grid cell REAL ( 8 ), INTENT ( IN ) :: tpp !! tracer value at the top   of the grid cell REAL ( 8 ), INTENT ( IN ) :: te !! environmental value for tracer in the grid cell REAL ( 8 ), INTENT ( IN ) :: apm !! fractional area at the bottom of the grid cell REAL ( 8 ), INTENT ( IN ) :: app !! fractional area at the top   of the grid cell REAL ( 8 ), INTENT ( IN ) :: wpm !! vertical velocity at the bottom of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: wpp !! vertical velocity at the top of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: Bp !! plume buoyancy forcing term [m/s2] REAL ( 8 ), INTENT ( IN ) :: Hz !! thickness of the grid cell [m] REAL ( 8 ), INTENT ( IN ) :: delta0 !! background detrainement in the entrainment zone [m-1] REAL ( 8 ), INTENT ( IN ) :: cent !! parameter of the MF scheme REAL ( 8 ), INTENT ( IN ) :: cdel !! parameter of the MF scheme ! local variables REAL ( 8 ) :: cffm , cffp , apowp , cff , back ! !back  = delta0*0.25*(wpp+wpm)**2/(-cdel) back = delta0 * 0.5 * ( wpp * wpp + wpm * wpm ) / ( - cdel ) cff = cent * MIN ( Bp , 0. ) * te - cdel * MAX ( Bp , back ) * tpp cffp = app * wpp * tpp apowp = ( app + apm ) / ( wpp + wpm ) cffm = cffp - Hz * apowp * cff !tpm   = cffm/(apm*wpm) ! IF ( apm > 0. ) THEN tpm = cffm / ( apm * wpm ) ELSE tpm = tpp ENDIF return !--------------------------------------------------------------------------------------------------- END SUBROUTINE get_t_p_P09 !=================================================================================================== !=================================================================================================== SUBROUTINE get_w_p_P09 ( wpm , wpp , aa , bb , bpr , cent , Hz , Bp , h , found ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE get_w_p_P09  ***                           <br /> !! ** Purposes : compute plume vertical velocity for Pergaud et al. (2009) !!                        entrainment/detrainement closure                  <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( INOUT ) :: wpm !! vertical velocity at the bottom of the grid cell [m/s] REAL ( 8 ), INTENT ( INOUT ) :: h !! distance from the top of the grid cell where w_p = w_p_min [m] LOGICAL , INTENT ( INOUT ) :: found !! (=T) the bottom of the plume is reached REAL ( 8 ), INTENT ( IN ) :: wpp !! vertical velocity at the top of the grid cell [m/s] REAL ( 8 ), INTENT ( IN ) :: Bp !! plume buoyancy forcing term [m/s2] REAL ( 8 ), INTENT ( IN ) :: Hz !! thickness of the grid cell [m] REAL ( 8 ), INTENT ( IN ) :: aa !! parameter of the MF scheme REAL ( 8 ), INTENT ( IN ) :: bb !! parameter of the MF scheme REAL ( 8 ), INTENT ( IN ) :: bpr !! parameter of the MF scheme REAL ( 8 ), INTENT ( IN ) :: cent !! parameter of the MF scheme ! local variables REAL ( 8 ) :: cff1 , cff , rhsw , wpm2 ! rhsw = ( aa - bb * cent ) * MIN ( Bp , 0. ) + aa * MAX ( Bp , 0. ) cff1 = 1. / ( 1. + Hz * bpr ) cff = ( 1. - Hz * bpr ) * wpp * wpp - 2. * Hz * rhsw wpm2 = cff1 * cff ! finalize computation wpm = - SQRT ( MAX ( wpm2 , wpmin * wpmin ) ) ! h = ( wpp * wpp - wpmin * wpmin ) / & ( 2. * rhsw + bpr * ( wpp * wpp + wpmin * wpmin )) IF ( h > 0. . AND . h < Hz ) found = . true . return !--------------------------------------------------------------------------------------------------- END SUBROUTINE get_w_p_P09 !=================================================================================================== !=================================================================================================== SUBROUTINE mass_flux_P09 ( u_m , v_m , t_m , z_w , Hz , tp0 , up0 , vp0 , wp0 , mf_params , alpha , beta , small_ap , zinv , & N , ntra , nparams , a_p , u_p , v_p , w_p , t_p , B_p , ent , det ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE mass_flux_P09  ***                           <br /> !! ** Purposes : solve mass-flux equations for Pergaud et al. (2009) !!                        entrainment/detrainement closure                  <br /> !! \\begin{align*} E &= \\frac{C_\\epsilon a&#94;{\\rm p}}{w&#94;{\\rm p}}  \\min(0, B&#94;{\\rm p}) \\\\ !!                D &= \\frac{C_\\delta a&#94;{\\rm p}}{w&#94;{\\rm p}} \\max( 0, B&#94;{\\rm p}) - a&#94;{\\rm p}w&#94;{\\rm p}\\delta_0  \\end{align*} !!==========================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels INTEGER , INTENT ( IN ) :: ntra !! number of tracers INTEGER , INTENT ( IN ) :: nparams !! number of parameters in the EDOs REAL ( 8 ), INTENT ( IN ) :: z_w ( 0 : N ) !! depth at cell interfaces [m] REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: u_m ( 1 : N ) !! mean zonal velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: v_m ( 1 : N ) !! mean meridional velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: t_m ( 1 : N , ntra ) !! mean tracer REAL ( 8 ), INTENT ( IN ) :: up0 !! surface value for plume zonal velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: vp0 !! surface value for plume meridional velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: wp0 !! surface value for plume vertical velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: tp0 ( 1 : ntra ) !! surface value for plume tracers REAL ( 8 ), INTENT ( IN ) :: mf_params ( 1 : nparams ) !! parameters in the ODEs REAL ( 8 ), INTENT ( IN ) :: alpha !! thermal expension coefficient [C-1] REAL ( 8 ), INTENT ( IN ) :: beta !! haline expension coefficient [psu-1] LOGICAL , INTENT ( IN ) :: small_ap !! (T) small area approximation (F) no approximation REAL ( 8 ), INTENT ( OUT ) :: a_p ( 0 : N ) !! fractional area occupied by the plume REAL ( 8 ), INTENT ( OUT ) :: w_p ( 0 : N ) !! vertical velocity in the plume [m/s] REAL ( 8 ), INTENT ( OUT ) :: u_p ( 0 : N ) !! zonal velocity in the plume [m/s] REAL ( 8 ), INTENT ( OUT ) :: v_p ( 0 : N ) !! meridional velocity in the plume [m/s] REAL ( 8 ), INTENT ( OUT ) :: t_p ( 0 : N , ntra ) !! tracer values in the plume REAL ( 8 ), INTENT ( OUT ) :: B_p ( 0 : N ) !! buoyancy forcing  [m/s2] REAL ( 8 ), INTENT ( OUT ) :: ent ( 1 : N ) !! diagnostics : entrainment [m-1] REAL ( 8 ), INTENT ( OUT ) :: det ( 1 : N ) !! diagnostics : detrainment [m-1] REAL ( 8 ), INTENT ( INOUT ) :: zinv !! depth at which w_p = wmin  [m] ! local variables INTEGER :: k , itrc , iter REAL ( 8 ) :: cff , cff1 , rho_m ( 1 : N ), N2sfc REAL ( 8 ) :: aa , bb , bp , cent , cdet , hinv , rho_p , rho_w REAL ( 8 ) :: Cu , Cv , delta0 , zbb , zbp , t_env , u_env , v_env REAL ( 8 ) :: temp_p , salt_p REAL ( 8 ) :: cffu , cffv , cffw , apr , tke_env LOGICAL :: found = . false . !======================================================================= ! initialize plume properties with surface values a_p ( N ) = mf_params ( nparams - 1 ) ; a_p ( 0 : N - 1 ) = 0. w_p ( N ) = wp0 ; w_p ( 0 : N - 1 ) = 0. u_p ( N ) = up0 ; u_p ( 0 : N - 1 ) = 0. v_p ( N ) = up0 ; v_p ( 0 : N - 1 ) = 0. t_p ( N , 1 : ntra ) = tp0 ( 1 : ntra ) ; t_p ( 0 : N - 1 , 1 : ntra ) = 0. B_p ( 0 : N ) = 0. ; ent ( 1 : N ) = 0. ; det ( 1 : N ) = 0. !======================================================================= ! Linear eos version !======================================================================= DO k = 1 , N CALL eos_val_lin ( t_m ( k , 1 ), t_m ( k , 2 ), alpha , beta , rho_m ( k )) !CALL eos_val (t_m(k,1),t_m(k,2),0.5*(z_w(k)+z_w(k-1)),rho_m(k)) ENDDO !======================================================================= ! unpack parameters cent = mf_params ( 1 ); cdet = mf_params ( 2 ); aa = mf_params ( 3 ) bb = mf_params ( 4 ); bp = mf_params ( 5 ) Cu = mf_params ( 6 ); Cv = mf_params ( 7 ); delta0 = mf_params ( nparams ) !======================================================================= DO k = N , 1 , - 1 !! Compute  B&#94;{\\rm p}_{k}   B&#94;{\\rm p}_{k} = - \\frac{g}{\\rho_0} \\left( \\rho&#94;{\\rm p}_{k+1/2} - \\overline{\\rho}_k \\right)  temp_p = t_p ( k , 1 ); salt_p = t_p ( k , 2 ) CALL eos_val_lin ( temp_p , salt_p , alpha , beta , rho_p ) !CALL eos_val(temp_p,salt_p,0.5*(z_w(k)+z_w(k-1)),rho_p) B_p ( k ) = - grav * ( rho_p - rho_m ( k ) ) / rho0 !! Compute  w&#94;{\\rm p}_{k-1/2}  !! (w&#94;{\\rm p})&#94;{2}_{k+1/2} - (w&#94;{\\rm p})&#94;{2}_{k-1/2} = !!  h_k b' \\left((w&#94;{\\rm p})&#94;{2}_{k+1/2} + (w&#94;{\\rm p})&#94;{2}_{k-1/2}\\right) !! + 2 h_k \\left( a \\max(B&#94;{\\rm p}_{k},0) + (a-b C_\\epsilon) \\min(B&#94;{\\rm p}_{k},0)  \\right) cff = 1. IF (. not . small_ap ) cff = 1. / ( 1. - a_p ( k )) zbb = cff * bb ; zbp = cff * bp CALL get_w_p_P09 ( w_p ( k - 1 ), w_p ( k ), aa , zbb , zbp , cent , Hz ( k ), B_p ( k ), hinv , found ) IF ( found ) THEN zinv = z_w ( k ) - hinv ; found = . false . ENDIF !! Compute  a&#94;{\\rm p}_{k-1/2}  !!  (a&#94;{\\rm p}w&#94;{\\rm p})_{k+1/2} -(a&#94;{\\rm p}w&#94;{\\rm p})_{k-1/2} = !! \\frac{a&#94;{\\rm p}_{k+1/2}+a&#94;{\\rm p}_{k-1/2}}{w&#94;{\\rm p}_{k+1/2}+w&#94;{\\rm p}_{k-1/2}} !! \\left( C_\\epsilon h_k \\min(B&#94;{\\rm p}_{k},0) - C_\\delta h_k \\max(B&#94;{\\rm p}_{k}, !! - \\frac{\\delta_0}{2 C_\\delta} \\left((w&#94;{\\rm p})&#94;{2}_{k+1/2} + (w&#94;{\\rm p})&#94;{2}_{k-1/2}\\right) )   \\right)   CALL get_a_p_P09 ( a_p ( k - 1 ), a_p ( k ), w_p ( k - 1 ), w_p ( k ), Hz ( k ), B_p ( k ), delta0 , cent , cdet ) ! cff = a_p ( k ) / ( 1. - a_p ( k )) IF ( small_ap ) cff = 0. ! DO itrc = 1 , ntra - 1 t_env = t_m ( k , itrc ) + cff * ( t_m ( k , itrc ) - t_p ( k , itrc )) !! Compute environment  \\phi&#94;{\\rm e}_k  CALL get_t_p_P09 ( t_p ( k - 1 , itrc ), t_p ( k , itrc ), t_env , & a_p ( k - 1 ), a_p ( k ), w_p ( k - 1 ), w_p ( k ), Hz ( k ), B_p ( k ), delta0 , Cent , Cdet ) ENDDO ! Compute up - Cu ue u_env = ( 1. - Cu ) * u_m ( k ) + cff * ( ( 1. - Cu ) * u_m ( k ) - u_p ( k ) ) CALL get_t_p_P09 ( u_p ( k - 1 ), u_p ( k ), u_env , & a_p ( k - 1 ), a_p ( k ), w_p ( k - 1 ), w_p ( k ), Hz ( k ), B_p ( k ), delta0 , Cent , Cdet ) ! Compute vp - Cv ve v_env = ( 1. - Cv ) * v_m ( k ) + cff * ( ( 1. - Cv ) * v_m ( k ) - v_p ( k ) ) CALL get_t_p_P09 ( v_p ( k - 1 ), v_p ( k ), v_env , & a_p ( k - 1 ), a_p ( k ), w_p ( k - 1 ), w_p ( k ), Hz ( k ), B_p ( k ), delta0 , Cent , Cdet ) ! Compute modified environment term for TKE cffw = w_p ( k ) cffu = u_p ( k ) + ( Cu - 1. ) * u_m ( k ) cffv = v_p ( k ) + ( Cv - 1. ) * v_m ( k ) tke_env = t_m ( k , ntra ) + 0.5 * ( 1. + cff ) * ( cffu * cffu + cffv * cffv + cffw * cffw ) & + cff * ( t_m ( k , ntra ) - t_p ( k , ntra )) ! CALL get_t_p_P09 ( t_p ( k - 1 , ntra ), t_p ( k , ntra ), tke_env , & a_p ( k - 1 ), a_p ( k ), w_p ( k - 1 ), w_p ( k ), Hz ( k ), B_p ( k ), delta0 , Cent , Cdet ) ! diagnostics ent ( k ) = MAX ( 0. , - 2. * Cent * B_p ( k ) / ( w_p ( k - 1 ) * w_p ( k - 1 ) + w_p ( k ) * w_p ( k )) ) det ( k ) = MAX ( delta0 , - 2. * Cdet * B_p ( k ) / ( w_p ( k - 1 ) * w_p ( k - 1 ) + w_p ( k ) * w_p ( k )) ) ! ENDDO !======================================================================= ! At this point, up and vp contain up-Cu ue  and vp-Cv ve u_p ( N ) = up0 ; v_p ( N ) = vp0 DO k = 1 , N - 1 u_p ( k ) = u_p ( k ) + Cu * u_m ( k ) v_p ( k ) = v_p ( k ) + Cv * v_m ( k ) ENDDO u_p ( 0 ) = u_p ( 1 ); v_p ( 0 ) = v_p ( 1 ) !--------------------------------------------------------------------------------------------------- END SUBROUTINE mass_flux_P09 !=================================================================================================== !=================================================================================================== SUBROUTINE mass_flux_R10 ( u_m , v_m , t_m , tke_m , z_w , Hz , tp0 , up0 , vp0 , wp0 , mf_params , alpha , beta , small_ap , lin_eos , zinv , & N , ntra , nparams , a_p , u_p , v_p , w_p , t_p , B_p , ent , det , eps ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE mass_flux_R10  ***                         <br /> !! ** Purposes : solve mass-flux equations for Rio et al. (2010) !!                        entrainment/detrainement closure                  <br /> !! \\begin{align*} E &= a&#94;{\\rm p} \\beta_1 \\max(0, \\partial_z w&#94;{\\rm p}) \\\\ !!                D &= - a&#94;{\\rm p} \\beta_2 \\min\\left( 0 , \\partial_z w&#94;{\\rm p} \\right) -  a&#94;{\\rm p} w&#94;{\\rm p} \\delta_0  \\end{align*} <br /> !!@note we must have  \\beta_1 < 1  and  1 < \\beta_2 < 2  otherwise unphysical values of  a&#94;{\\rm p}  are obtained  @endnote <br /> !! \\begin{align*} !! \\partial_z(a&#94;{\\rm p} w&#94;{\\rm p}) &= E-D  \\\\ !! \\partial_z(a&#94;{\\rm p} w&#94;{\\rm p} \\phi&#94;{\\rm p}) &= E \\phi&#94;{\\rm e} - D \\phi&#94;{\\rm p} !! =   E \\left\\{ \\overline{\\phi} + \\underbrace{\\frac{a&#94;{\\rm p}}{1-a&#94;{\\rm p}} (\\overline{\\phi}-\\phi&#94;{\\rm p})}_{\\rm mass\\_flux\\_small\\_ap=False} \\right\\} - D \\phi&#94;{\\rm p} \\\\ !! w&#94;{\\rm p} \\partial_z w&#94;{\\rm p} &= \\left( 1 + \\underbrace{\\frac{a&#94;{\\rm p}}{1-a&#94;{\\rm p}}}_{\\rm mass\\_flux\\_small\\_ap=False} \\right) \\left[ b' + b \\epsilon \\right] (w&#94;{\\rm p})&#94;2 + a B&#94;{\\rm p} \\\\ !! \\partial_z(e&#94;{\\rm p}-e) &= \\left( \\frac{E}{-a&#94;{\\rm p} w&#94;{\\rm p}} \\right) \\left[ \\left( 1 - \\underbrace{\\frac{a&#94;{\\rm p}}{1-a&#94;{\\rm p}}}_{\\rm mass\\_flux\\_small\\_ap=False}  \\right) (e&#94;{\\rm p}-e) - \\frac{1}{2} \\left( 1 + \\underbrace{\\frac{a&#94;{\\rm p}}{1-a&#94;{\\rm p}}}_{\\rm mass\\_flux\\_small\\_ap=False}  \\right) \\| \\mathbf{v}&#94;{\\rm p} - \\mathbf{v} \\|&#94;2    \\right] - \\partial_z e - \\frac{c_\\epsilon}{w&#94;{\\rm p} l_{\\epsilon}} e&#94;{\\rm p} \\sqrt{e&#94;{\\rm p}} \\\\ !! \\partial_z(a&#94;{\\rm p} w&#94;{\\rm p} [u&#94;{\\rm p}-C_u \\overline{u}]) &=  E \\left\\{  (1-C_u) \\overline{u} + \\underbrace{\\frac{a&#94;{\\rm p}}{1-a&#94;{\\rm p}}\\left( (1-C_u) \\overline{u} -[u&#94;{\\rm p}-C_u \\overline{u}]   \\right)}_{\\rm mass\\_flux\\_small\\_ap=False}  \\right\\} - D [u&#94;{\\rm p}-C_u \\overline{u}] !! \\end{align*}<br /> ! ! \\partial_z(a&#94;{\\rm p} w&#94;{\\rm p} e&#94;{\\rm p}) &=  E \\left\\{ e + \\frac{1}{2} \\| \\mathbf{v}&#94;{\\rm p} - \\mathbf{v} \\|&#94;2 + \\underbrace{\\frac{a&#94;{\\rm p}}{1-a&#94;{\\rm p}} \\left( (e-e&#94;{\\rm p}) + \\frac{1}{2} \\| \\mathbf{v}&#94;{\\rm p} - \\mathbf{v} \\|&#94;2 \\right)}_{\\rm mass\\_flux\\_small\\_ap=False} \\right\\} - D e&#94;{\\rm p}  \\\\ !!==========================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels INTEGER , INTENT ( IN ) :: ntra !! number of tracers INTEGER , INTENT ( IN ) :: nparams !! number of parameters in the EDOs REAL ( 8 ), INTENT ( IN ) :: z_w ( 0 : N ) !! depth at cell interfaces [m] REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: u_m ( 1 : N ) !! mean zonal velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: v_m ( 1 : N ) !! mean meridional velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: t_m ( 1 : N , ntra ) !! mean tracer REAL ( 8 ), INTENT ( IN ) :: tke_m ( 0 : N ) !! mean TKE [m2/s2] REAL ( 8 ), INTENT ( IN ) :: up0 !! surface value for plume zonal velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: vp0 !! surface value for plume meridional velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: wp0 !! surface value for plume vertical velocity [m/s] REAL ( 8 ), INTENT ( IN ) :: tp0 ( 1 : ntra ) !! surface value for plume tracers REAL ( 8 ), INTENT ( IN ) :: mf_params ( 1 : nparams ) !! parameters in the ODEs REAL ( 8 ), INTENT ( IN ) :: alpha !! thermal expension coefficient [C-1] REAL ( 8 ), INTENT ( IN ) :: beta !! haline expension coefficient [psu-1] LOGICAL , INTENT ( IN ) :: small_ap !! (T) small area approximation (F) no approximation LOGICAL , INTENT ( IN ) :: lin_eos !! REAL ( 8 ), INTENT ( OUT ) :: a_p ( 0 : N ) !! fractional area occupied by the plume REAL ( 8 ), INTENT ( OUT ) :: w_p ( 0 : N ) !! vertical velocity in the plume [m/s] REAL ( 8 ), INTENT ( OUT ) :: u_p ( 0 : N ) !! zonal velocity in the plume [m/s] REAL ( 8 ), INTENT ( OUT ) :: v_p ( 0 : N ) !! meridional velocity in the plume [m/s] REAL ( 8 ), INTENT ( OUT ) :: t_p ( 0 : N , ntra ) !! tracer values in the plume REAL ( 8 ), INTENT ( OUT ) :: B_p ( 0 : N ) !! buoyancy forcing  [m/s2] REAL ( 8 ), INTENT ( OUT ) :: ent ( 1 : N ) !! diagnostics : entrainment [m-1] REAL ( 8 ), INTENT ( OUT ) :: det ( 1 : N ) !! diagnostics : detrainment [m-1] REAL ( 8 ), INTENT ( OUT ) :: eps ( 1 : N ) !! diagnostics : TKE dissipation [m2 s-3] REAL ( 8 ), INTENT ( INOUT ) :: zinv !! depth at which w_p = wmin  [m] ! local variables REAL ( 8 ) :: delta0 INTEGER :: k , itrc , iter REAL ( 8 ) :: cff , cff1 , rho_m ( 1 : N ), N2sfc REAL ( 8 ) :: tke_env , u_env , v_env , t_env REAL ( 8 ) :: aa , bb , bp , beta1 , zbb , zbp REAL ( 8 ) :: hinv , rho_p , rho_w , idwdz0 REAL ( 8 ) :: cffu , cffv , cffw , apr , normVel REAL ( 8 ) :: temp_p , salt_p , Cu , Cv , tpm , apm , beta2 , cffmax LOGICAL :: found = . false . REAL ( 8 ) :: mxld ( 0 : N ), imxld0 ( 1 : N ) REAL ( 8 ) :: lup , ldwn , epsilon , dtke , rn2 !======================================================================= ! unpack parameters (mf_params  = [Cent,Cdet,wp_a,wp_b,wp_bp,up_c,vp_c,bc_ap] beta1 = mf_params ( 1 ); aa = mf_params ( 3 ) bb = mf_params ( 4 ); bp = mf_params ( 5 ) Cu = mf_params ( 6 ); Cv = mf_params ( 7 ) beta2 = mf_params ( 2 ); delta0 = mf_params ( nparams ) !======================================================================= ! initialize plume properties with surface values a_p ( N ) = mf_params ( nparams - 1 ) ; a_p ( 0 : N - 1 ) = 0. w_p ( N ) = wp0 ; w_p ( 0 : N - 1 ) = 0. u_p ( N ) = ( 1. - Cu ) * up0 ; u_p ( 0 : N - 1 ) = 0. v_p ( N ) = ( 1. - Cv ) * vp0 ; v_p ( 0 : N - 1 ) = 0. t_p ( N , 1 : ntra ) = tp0 ( 1 : ntra ) ; t_p ( 0 : N - 1 , 1 : ntra ) = 0. B_p ( 0 : N ) = 0. ; ent ( 1 : N ) = 0. ; det ( 1 : N ) = 0. ; eps ( 1 : N ) = 0. ! t_p ( N , ntra ) = 0. ! in this case t_p(ntra) contains t_p - tke ! DO k = 1 , N cff = 0.5 * ( z_w ( k ) + z_w ( k - 1 )) lup = MAX ( - cff , mxl_min ) ldwn = MAX ( cff - zinv , mxl_min ) imxld0 ( k ) = 1. / SQRT ( lup * ldwn ) ENDDO imxld0 ( N ) = 0.5 * ( 3. * imxld0 ( N - 1 ) - imxld0 ( N - 2 )) !imxld0(1:N) = 0. ! !======================================================================= ! Linear eos version !======================================================================= IF ( lin_eos ) THEN DO k = 1 , N CALL eos_val_lin ( t_m ( k , 1 ), t_m ( k , 2 ), alpha , beta , rho_m ( k )) ENDDO ELSE DO k = 1 , N CALL eos_val ( t_m ( k , 1 ), t_m ( k , 2 ), 0.5 * ( z_w ( k ) + z_w ( k - 1 )), rho_m ( k )) ENDDO ENDIF !======================================================================= N2sfc = - ( grav / rho0 ) * ( rho_m ( N ) - rho_m ( N - 1 )) / Hz ( N ) !======================================================================= DO k = N , 1 , - 1 ! Compute B_p temp_p = t_p ( k , 1 ); salt_p = t_p ( k , 2 ) ! IF ( lin_eos ) THEN ; CALL eos_val_lin ( temp_p , salt_p , alpha , beta , rho_p ) ELSE ; CALL eos_val ( temp_p , salt_p , 0.5 * ( z_w ( k ) + z_w ( k - 1 )), rho_p ); ENDIF !! Compute  B&#94;{\\rm p}_{k}   B&#94;{\\rm p}_{k} = - \\frac{g}{\\rho_0} \\left( \\rho&#94;{\\rm p}_{k+1/2} - \\overline{\\rho}_k \\right)  B_p ( k ) = - grav * ( rho_p - rho_m ( k ) ) / rho0 ! Wp equation first !! If  {\\rm small\\_ap = False} : (b',b) \\rightarrow \\frac{(b',b)}{1-a&#94;{\\rm p}_{k+1/2}}  <br /> cff = 1. IF (. not . small_ap ) cff = 1. / ( 1. - a_p ( k )) zbb = cff * bb ; zbp = cff * bp !! Compute  w&#94;{\\rm p}_{k-1/2}  :: call   {\\rm get\\_w\\_p\\_R10}   !   (w&#94;{\\rm p})&#94;{2}_{k+1/2} - (w&#94;{\\rm p})&#94;{2}_{k-1/2} = !  h_k (b' + b \\epsilon_k) \\left((w&#94;{\\rm p})&#94;{2}_{k+1/2} + (w&#94;{\\rm p})&#94;{2}_{k-1/2})\\right) ! + 2 a h_k B&#94;{\\rm p}_{k} CALL get_w_p_R10 ( w_p ( k - 1 ), w_p ( k ), aa , zbb , zbp , beta1 , Hz ( k ), B_p ( k ), hinv , found ) ! diagnostics cff = ( w_p ( k ) - w_p ( k - 1 )) / ( 0.5 * Hz ( k ) * ( w_p ( k ) + w_p ( k - 1 ))) ent ( k ) = MAX ( 0. , - beta1 * cff ) det ( k ) = MAX ( 0. , beta2 * cff ) + delta0 !IF( det(k)-1. == det(k) ) THEN !  print*,'det(k) = ',det(k),cff,w_p(k),beta2 !ENDIF ! IF ( found ) THEN zinv = z_w ( k ) - hinv ; found = . false . ENDIF !! Compute  a&#94;{\\rm p}_{k-1/2}  :: call   {\\rm get\\_a\\_p\\_R10}   !   (a&#94;{\\rm p} w&#94;{\\rm p})_{k-\\frac{1}{2}}  =   (a&#94;{\\rm p} w&#94;{\\rm p})_{k+\\frac{1}{2}} ! - \\beta_1 \\left(\\frac{a&#94;{\\rm p}_{k+\\frac{1}{2}} + a&#94;{\\rm p}_{k-\\frac{1}{2}} }{2}\\right) ! \\left(  \\max(0, (\\delta_z w&#94;{\\rm p})_k) + \\min\\left( \\frac{w&#94;{\\rm p} h_k}{\\beta_1} \\delta_0 , ! (\\delta_z w&#94;{\\rm p})_k + \\frac{w&#94;{\\rm p} h_k}{\\beta_1} (\\delta_1)_k \\right) \\right) \\\\   CALL get_a_p_R10 ( a_p ( k - 1 ), a_p ( k ), w_p ( k - 1 ), w_p ( k ), beta1 , beta2 , Hz ( k ), delta0 ) cff = a_p ( k ) / ( 1. - a_p ( k )) IF ( small_ap ) cff = 0. ! Compute tracers (except TKE_p) DO itrc = 1 , ntra - 1 t_env = t_m ( k , itrc ) + cff * ( t_m ( k , itrc ) - t_p ( k , itrc )) !! Compute environment  \\phi&#94;{\\rm e}_k !!\\begin{align*} !! \\phi&#94;{\\rm e}_k &= \\overline{\\phi}_k  \\hspace{7cm} \\mbox{small_ap = True} \\\\ !! \\phi&#94;{\\rm e}_k &= \\overline{\\phi}_k + \\left( \\frac{a&#94;{\\rm p}_{k+1/2}}{1-a&#94;{\\rm p}_{k+1/2}} \\right) ( \\overline{\\phi}_k - \\phi&#94;{\\rm p}_{k+1/2} ) \\hspace{1cm} \\mbox{small_ap = False} !! \\end{align*} CALL get_t_p_R10 ( t_p ( k - 1 , itrc ), t_p ( k , itrc ), t_env , & a_p ( k - 1 ), a_p ( k ), w_p ( k - 1 ), w_p ( k ), beta1 , beta2 , Hz ( k ), delta0 ) !! Compute  \\phi&#94;{\\rm p}_{k-1/2} :: call   {\\rm get\\_t\\_p\\_R10}   ENDDO ! Compute up - Cu umean u_env = ( 1. - Cu ) * u_m ( k ) + cff * ( ( 1. - Cu ) * u_m ( k ) - u_p ( k ) ) CALL get_t_p_R10 ( u_p ( k - 1 ), u_p ( k ), u_env , a_p ( k - 1 ), a_p ( k ), w_p ( k - 1 ), w_p ( k ), & beta1 , beta2 , Hz ( k ), delta0 ) !! Compute  u&#94;{\\rm p}_{k-1/2} :: call   {\\rm get\\_t\\_p\\_R10}   ! Compute vp - Cv vmean v_env = ( 1. - Cv ) * v_m ( k ) + cff * ( ( 1. - Cv ) * v_m ( k ) - v_p ( k ) ) CALL get_t_p_R10 ( v_p ( k - 1 ), v_p ( k ), v_env , a_p ( k - 1 ), a_p ( k ), w_p ( k - 1 ), w_p ( k ), & beta1 , beta2 , Hz ( k ), delta0 ) !! Compute  v&#94;{\\rm p}_{k-1/2} :: call   {\\rm get\\_t\\_p\\_R10}   ! Compute TKEplume - TKEmean cff = a_p ( k ) / ( 1. - a_p ( k )) IF ( small_ap ) cff = 0. cffw = 0.5 * ( w_p ( k ) + w_p ( k - 1 )) cffu = 0.5 * ( u_p ( k ) + u_p ( k - 1 )) + ( Cu - 1. ) * u_m ( k ) cffv = 0.5 * ( v_p ( k ) + v_p ( k - 1 )) + ( Cv - 1. ) * v_m ( k ) normVel = ( 1. + cff ) * ( cffu * cffu + cffv * cffv + cffw * cffw ) / ( 1. - cff ) dtke = tke_m ( k ) - tke_m ( k - 1 ) epsilon = ceps_nemo * ( t_p ( k , ntra ) + tke_m ( k )) & * SQRT ( t_p ( k , ntra ) + tke_m ( k )) * imxld0 ( k ) CALL get_dtke_p_R10 ( t_p ( k - 1 , ntra ), t_p ( k , ntra ), dtke , normVel , w_p ( k - 1 ), w_p ( k ), & Hz ( k ), epsilon ,( 1. - cff ) * beta1 ) !! Compute  e&#94;{\\rm p}_{k-1/2} :: call   {\\rm get\\_dtke\\_p\\_R10}   eps ( k ) = epsilon ENDDO !======================================================================= ! At this point, up and vp contain up-Cu ue  and vp-Cv ve u_p ( N ) = up0 ; v_p ( N ) = vp0 DO k = 1 , N - 1 u_p ( k ) = u_p ( k ) + Cu * u_m ( k ) v_p ( k ) = v_p ( k ) + Cv * v_m ( k ) ENDDO u_p ( 0 ) = u_p ( 1 ); v_p ( 0 ) = v_p ( 1 ) ! DO k = 0 , N t_p ( k , ntra ) = MAX ( t_p ( k , ntra ) + tke_m ( k ), tke_min ) ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE mass_flux_R10 !=================================================================================================== END MODULE scm_mfc","tags":"","loc":"sourcefile/scm_mfc.f90.html"},{"title":"scm_oce.f90 – SCM-EDMF ocean","text":"Source Code MODULE scm_oce !!============================================================================<br /> !!                       ***  MODULE  scm_oce  ***                            <br /> !! Single Column Model (SCM) time-stepping and oceanic equation of state      <br /> !!============================================================================<br /> !!----------------------------------------------------------------------------<br /> !!   advance_tra_ED     : integrate eddy-diffusion term for tracers           <br /> !!   advance_tra_MF     : integrate mass-flux term for tracers                <br /> !!   advance_dyn_MF     : integrate mass-flux term for dynamics               <br /> !!   advance_dyn_Cor_ED : integrate eddy-viscosity and Coriolis terms for dynamics <br /> !!   compute_evd        : compute Enhanced Vertical Diffusion (EVD)           <br /> !!   lmd_swfrac         : compute fraction of solar penetration               <br /> !!   rho_eos_lin        : linear equation of state                            <br /> !!   tridiag_solve      : tridiagonal solver                                  <br /> !!----------------------------------------------------------------------------<br /> IMPLICIT NONE CONTAINS !=================================================================================================== SUBROUTINE advance_tra_ED ( t_n , stflx , srflx , swr_frac , Hz , Akt , zw , eps , alpha , dt , N , ntra , t_np1 ) !--------------------------------------------------------------------------------------------------- !!============================================================================<br /> !!                  ***  ROUTINE advance_tra_ED  ***                          <br /> !! ** Purposes : integrate vertical diffusion term for tracers                <br /> !!============================================================================<br /> !!  \\overline{\\phi}&#94;{n+1,*} = \\overline{\\phi}&#94;n + \\Delta t \\partial_z \\left(  K_m \\partial_z  \\overline{\\phi}&#94;{n+1,*} \\right)  USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels INTEGER , INTENT ( IN ) :: ntra !! number of tracers to integrate REAL ( 8 ), INTENT ( IN ) :: dt !! time-step [s] REAL ( 8 ), INTENT ( IN ) :: t_n ( 1 : N , ntra ) !! tracer at time step n REAL ( 8 ), INTENT ( IN ) :: stflx ( ntra ) !! surface tracer fluxes REAL ( 8 ), INTENT ( IN ) :: srflx !! surface radiative flux [W/m2] REAL ( 8 ), INTENT ( IN ) :: swr_frac ( 0 : N ) !! fraction of solar penetration REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: Akt ( 0 : N ) !! eddy-diffusivity [m2/s] REAL ( 8 ), INTENT ( IN ) :: eps ( 0 : N ) !! TKE dissipation [m2/s3] REAL ( 8 ), INTENT ( IN ) :: zw ( 0 : N ) !! depth at cell interfaces [m] REAL ( 8 ), INTENT ( IN ) :: alpha !! thermal expension coefficient [C-1] REAL ( 8 ), INTENT ( OUT ) :: t_np1 ( 1 : N , ntra ) !! tracer at time step n+1 ! local variables INTEGER :: k , itrc REAL ( 8 ) :: FC ( 0 : N ), ff ( 1 : N ), cffp , cffm ! DO itrc = 1 , ntra FC ( 0 ) = 0. ; FC ( N ) = 0. !======================================================================= !! 1 - Compute fluxes associated to solar penetration and surface bdy condition <br /> !======================================================================= IF ( itrc . eq . 1 ) then FC ( N ) = stflx ( itrc ) + srflx !<-- surface heat flux (including latent and solar components) FC ( 1 : N - 1 ) = srflx * swr_frac ( 1 : N - 1 ) !<-- penetration of solar heat flux ELSE FC ( N ) = stflx ( itrc ) !<-- salinity (fresh water flux) FC ( 1 : N - 1 ) = 0.D0 ENDIF ! Apply flux divergence DO k = 1 , N t_np1 ( k , itrc ) = Hz ( k ) * t_n ( k , itrc ) + dt * ( FC ( k ) - FC ( k - 1 )) ENDDO IF ( itrc . eq . 1 ) then DO k = 1 , N cffp = eps ( k ) / ( cp - alpha * grav * zw ( k ) ) cffm = eps ( k - 1 ) / ( cp - alpha * grav * zw ( k - 1 ) ) t_np1 ( k , itrc ) = t_np1 ( k , itrc ) + dt * 0.5 * Hz ( k ) * ( cffp + cffm ) ENDDO ENDIF !======================================================================= !! 2 - Implicit integration for vertical diffusion <br /> !======================================================================= ! right hand side for the tridiagonal problem ff ( 1 : N ) = t_np1 ( 1 : N , itrc ) ! solve tridiagonal problem CALL tridiag_solve ( N , Hz , Akt , 0. * FC , 0.d8 , ff , dt ) ! update tracer t_np1 ( 1 : N , itrc ) = ff ( 1 : N ) !----------- ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE advance_tra_ED !=================================================================================================== !=================================================================================================== SUBROUTINE advance_tra_MF ( t_np1 , t_p , Fmass , Hz , dt , N , ntra ) !--------------------------------------------------------------------------------------------------- !!============================================================================<br /> !!                  ***  ROUTINE advance_tra_MF  ***                          <br /> !! ** Purposes : integrate mass flux term for tracers                         <br /> !!============================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels INTEGER , INTENT ( IN ) :: ntra !! number of tracers to integrate REAL ( 8 ), INTENT ( IN ) :: dt !! time-step [s] REAL ( 8 ), INTENT ( IN ) :: t_p ( 0 : N , ntra + 1 ) !! tracer properties in the plume REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: Fmass ( 0 : N ) !! mass flux [m/s] REAL ( 8 ), INTENT ( INOUT ) :: t_np1 ( 1 : N , ntra ) !! tracer at time step n+1 ! local variables INTEGER :: k , itrc REAL ( 8 ) :: cff , FC ( 0 : N ) ! DO itrc = 1 , ntra FC ( 0 ) = 0. !; FC(N) = 0. ! Compute fluxes associated to mass flux DO k = 1 , N FC ( k ) = Fmass ( k ) * ( t_p ( k , itrc ) - t_np1 ( k , itrc )) !! Compute fluxes associated to mass flux  F_{k+1/2}&#94;{\\rm MF} = (a&#94;{\\rm p}w&#94;{\\rm p})_{k+1/2}\\left( \\phi&#94;{\\rm p}_{k+1/2} - \\overline{\\phi}_k&#94;{n+1,\\star} \\right)   <br /> ENDDO FC ( N ) = 0. ! Apply flux divergence DO k = 1 , N t_np1 ( k , itrc ) = t_np1 ( k , itrc ) + dt * ( FC ( k ) - FC ( k - 1 )) / Hz ( k ) !!    \\overline{\\phi}_k&#94;{n+1} = \\overline{\\phi}_k&#94;{n+1,\\star} + \\frac{\\Delta t}{\\Delta z_k} ( F_{k+1/2}&#94;{\\rm MF}-F_{k-1/2}&#94;{\\rm MF} )    ENDDO ENDDO ! !--------------------------------------------------------------------------------------------------- END SUBROUTINE advance_tra_MF !=================================================================================================== !=================================================================================================== SUBROUTINE advance_dyn_MF ( u_np1 , v_np1 , shear2_MF , u_n , v_n , u_p , v_p , Fmass , Hz , dt , N ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE advance_dyn_MF  ***                        <br /> !! ** Purposes : integrate mass flux term for dynamics and compute transfer !!                         of KE to TKE related to the mass flux            <br /> !!==========================================================================<br /> !!  \\mathbf{u}&#94;{n+1} = \\mathbf{u}&#94;{n+1,\\star \\star} - \\Delta t \\partial_z\\left( a&#94;{\\rm p} w&#94;{\\rm p} \\left( \\mathbf{u}&#94;{\\rm p} - \\mathbf{u}&#94;{n+1,\\star \\star}  \\right)   \\right)  !! Compute the shear term associated with mass flux !!  {\\rm Sh}&#94;{\\rm p} = - a&#94;{\\rm p} w&#94;{\\rm p} \\left( \\mathbf{u}&#94;{\\rm p} - \\mathbf{u}&#94;{n+1,\\star \\star}  \\right) \\cdot \\frac{1}{2} \\left( \\partial_z \\mathbf{u}&#94;n + \\partial_z \\mathbf{u}&#94;{n+1}  \\right)  USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: dt !! time-step [s] REAL ( 8 ), INTENT ( INOUT ) :: u_np1 ( 1 : N ) !! u-velocity component at time n+1 [m/s] REAL ( 8 ), INTENT ( INOUT ) :: v_np1 ( 1 : N ) !! v-velocity component at time n+1 [m/s] REAL ( 8 ), INTENT ( INOUT ) :: shear2_MF ( 0 : N ) !! TKE production term associated to mass flux [m2/s3] REAL ( 8 ), INTENT ( IN ) :: u_n ( 1 : N ) !! u-velocity component at time n [m/s] REAL ( 8 ), INTENT ( IN ) :: v_n ( 1 : N ) !! v-velocity component at time n [m/s] REAL ( 8 ), INTENT ( IN ) :: u_p ( 0 : N ) !! u-velocity component in the plume [m/s] REAL ( 8 ), INTENT ( IN ) :: v_p ( 0 : N ) !! v-velocity component in the plume [m/s] REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: Fmass ( 0 : N ) !! mass flux [m/s] ! local variables INTEGER :: k REAL ( 8 ) :: cff , FCu ( 0 : N ), FCv ( 0 : N ) REAL ( 8 ) :: cffu , cffv ! FCu ( 0 ) = 0. ; FCv ( 0 ) = 0. ! Compute fluxes associated to mass flux DO k = 1 , N FCu ( k ) = Fmass ( k ) * ( u_p ( k ) - u_np1 ( k )) FCv ( k ) = Fmass ( k ) * ( v_p ( k ) - v_np1 ( k )) ENDDO FCu ( N ) = 0. ; FCv ( N ) = 0. ! Apply flux divergence DO k = 1 , N u_np1 ( k ) = u_np1 ( k ) + dt * ( FCu ( k ) - FCu ( k - 1 )) / Hz ( k ) v_np1 ( k ) = v_np1 ( k ) + dt * ( FCv ( k ) - FCv ( k - 1 )) / Hz ( k ) ENDDO ! Compute shear term for TKE shear2_MF ( 0 ) = 0. shear2_MF ( N ) = 0. ! DO k = 1 , N - 1 ! use upwind value for u_np1/v_np1 cffu = Fcu ( k ) * 0.5 * ( ( u_np1 ( k + 1 ) + u_n ( k + 1 )) - ( u_np1 ( k ) + u_n ( k )) ) cffv = FCv ( k ) * 0.5 * ( ( v_np1 ( k + 1 ) + v_n ( k + 1 )) - ( v_np1 ( k ) + v_n ( k )) ) shear2_MF ( k ) = 2. * ( cffu + cffv ) / ( Hz ( k + 1 ) + Hz ( k )) ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE advance_dyn_MF !=================================================================================================== !=================================================================================================== SUBROUTINE advance_dyn_Cor_ED ( u_n , v_n , sustr , svstr , Hz , Akv , fcor , dt , nn , N , u_np1 , v_np1 ) !--------------------------------------------------------------------------------------------------- !!============================================================================<br /> !!                  ***  ROUTINE advance_dyn_Cor_ED  ***                      <br /> !! ** Purposes : integrate vertical viscosity and Coriolis terms for dynamics <br /> !!============================================================================<br /> !! 1- Compute Coriolis term <br /> !! if n is even !! \\begin{align*} !! u&#94;{n+1,\\star} &= u&#94;n + \\Delta t f v&#94;n \\\\ !! v&#94;{n+1,\\star} &= v&#94;n - \\Delta t f u&#94;{n+1,\\star} !! \\end{align*} !! if n is odd !! \\begin{align*} !! v&#94;{n+1,\\star} &= v&#94;n - \\Delta t f u&#94;n \\\\ !! u&#94;{n+1,\\star} &= u&#94;n + \\Delta t f v&#94;{n+1,\\star} !! \\end{align*} IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels INTEGER , INTENT ( IN ) :: nn !! index for alternating Coriolis integration REAL ( 8 ), INTENT ( IN ) :: dt !! time-step [s] REAL ( 8 ), INTENT ( IN ) :: fcor !! Coriolis frequaency [s-1] REAL ( 8 ), INTENT ( IN ) :: u_n ( 1 : N ) !! u-velocity component at time n [m/s] REAL ( 8 ), INTENT ( IN ) :: v_n ( 1 : N ) !! v-velocity component at time n [m/s] REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: Akv ( 0 : N ) !! eddy-viscosity [m2/s] REAL ( 8 ), INTENT ( IN ) :: sustr !! zonal surface stress      [m2/s2] REAL ( 8 ), INTENT ( IN ) :: svstr !! meridional surface stress [m2/s2] REAL ( 8 ), INTENT ( OUT ) :: u_np1 ( 1 : N ) !! u-velocity component at time n+1 [m/s] REAL ( 8 ), INTENT ( OUT ) :: v_np1 ( 1 : N ) !! v-velocity component at time n+1 [m/s] ! local variables INTEGER :: k REAL ( 8 ) :: FC ( 0 : N ), ff ( 1 : N ), cff , cff1 REAL ( 8 ) :: gamma_Cor = 0.55 ! cff = ( dt * fcor ) * ( dt * fcor ) cff1 = 1. / ( 1 + gamma_Cor * gamma_Cor * cff ) DO k = 1 , N u_np1 ( k ) = cff1 * Hz ( k ) * ( ( 1. - gamma_Cor * ( 1. - gamma_Cor ) * cff ) * u_n ( k ) & + dt * fcor * v_n ( k ) ) v_np1 ( k ) = cff1 * Hz ( k ) * ( ( 1. - gamma_Cor * ( 1. - gamma_Cor ) * cff ) * v_n ( k ) & - dt * fcor * u_n ( k ) ) ENDDO !IF(nn==1) THEN             !! 1 - Coriolis term <br /> !  DO k=1,N !    cff       = fcor * v_n(k) !    u_np1(k)  = u_n(k) + dt * cff !    cff       = fcor * u_np1(k) !    v_np1(k)  = Hz(k)*( v_n(k) - dt * cff  ) !    u_np1(k)  = Hz(k)*( u_np1(k)           ) !  ENDDO !ELSE !  DO k=1,N !    cff       = fcor * u_n(k) !    v_np1(k)  =         v_n(k)  - dt * cff !    cff       = fcor * v_np1(k) !    u_np1(k)  = Hz(k)*( u_n(k) + dt * cff  ) !    v_np1(k)  = Hz(k)*( v_np1(k)           ) !  ENDDO !ENDIF !! 2 - Apply surface forcing <br /> u_np1 ( N ) = u_np1 ( N ) + dt * sustr !<-- sustr is in m2/s2 here v_np1 ( N ) = v_np1 ( N ) + dt * svstr !======================================================================= !! 3 - Implicit integration for vertical viscosity <br /> !! \\begin{align*} !! \\mathbf{u}&#94;{n+1,\\star \\star} &= \\mathbf{u}&#94;{n+1,\\star} + \\Delta t \\partial_z \\left(  K_m \\partial_z  \\mathbf{u}&#94;{n+1,\\star \\star} \\right)  \\\\ !! \\end{align*} !======================================================================= ! u-component !-------------------------------------------------------- FC ( 0 : N ) = 0. ff ( 1 : N ) = u_np1 ( 1 : N ) CALL tridiag_solve ( N , Hz , Akv , FC , 0.d8 , ff , dt ) ! Invert tridiagonal matrix u_np1 ( 1 : N ) = ff ( 1 : N ) !EXP(-dt*sig(1:N))*ff(1:N) ! ! v-component !-------------------------------------------------------- ff ( 1 : N ) = v_np1 ( 1 : N ) CALL tridiag_solve ( N , Hz , Akv , FC , 0.d8 , ff , dt ) ! Invert tridiagonal matrix v_np1 ( 1 : N ) = ff ( 1 : N ) !EXP(-dt*sig(1:N))*ff(1:N) !@note A different time discretization of the Coriolis term could be tested ! to check the phase shift compared to MesoNH !@endnote<br /> !--------------------------------------------------------------------------------------------------- END SUBROUTINE advance_dyn_Cor_ED !=================================================================================================== !=================================================================================================== SUBROUTINE compute_evd ( bvf , Akv , Akt , AkEvd , N ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE compute_evd  ***                           <br /> !! ** Purposes : compute enhanced vertical diffusion/viscosity !!                                   where the density profile is unstable  <br /> !!==========================================================================<br /> IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: bvf ( 0 : N ) !! Brunt Vaisala frequency [s-2] REAL ( 8 ), INTENT ( INOUT ) :: Akv ( 0 : N ) !! eddy-viscosity [m2/s] REAL ( 8 ), INTENT ( INOUT ) :: Akt ( 0 : N ) !! eddy-diffusivity [m2/s] REAL ( 8 ), INTENT ( IN ) :: AkEvd !! value of enhanced diffusion [m2/s] ! local variables INTEGER :: k ! DO k = 1 , N - 1 IF ( bvf ( k ) <= - 1.e-12 ) THEN Akv ( k ) = AkEvd Akt ( k ) = AkEvd ENDIF ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE compute_evd !=================================================================================================== !=================================================================================================== SUBROUTINE lmd_swfrac ( Hz , N , swr_frac ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE lmd_swfrac  ***                            <br /> !! ** Purposes : Compute fraction of solar shortwave flux penetrating to specified !!                depth due to exponential decay in Jerlov water type.      <br /> !!==========================================================================<br /> IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( OUT ) :: swr_frac ( 0 : N ) !! fraction of solar penetration ! local variables INTEGER :: k REAL ( 8 ) swdk1 , swdk2 , xi1 , xi2 REAL ( 8 ) mu1 , mu2 , r1 , attn1 , attn2 !---------- mu1 = 0.35 ; mu2 = 2 3.0 ; r1 = 0.58 attn1 = - 1. / mu1 attn2 = - 1. / mu2 swdk1 = r1 ! surface, then attenuate swdk2 = 1. - swdk1 ! them separately throughout swr_frac ( N ) = 1. ! the water column. ! DO k = N , 1 , - 1 xi1 = attn1 * Hz ( k ) IF ( xi1 . gt . - 2 0. ) then ! this logic to avoid swdk1 = swdk1 * exp ( xi1 ) ! computing exponent for ELSE ! a very large argument swdk1 = 0. ENDIF xi2 = attn2 * Hz ( k ) IF ( xi2 . gt . - 2 0. ) then swdk2 = swdk2 * exp ( xi2 ) ELSE swdk2 = 0. ENDIF swr_frac ( k - 1 ) = swdk1 + swdk2 ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE lmd_swfrac !=================================================================================================== !=================================================================================================== SUBROUTINE compute_mxl ( bvf , rhoc10 , rhoc300 , zr , N , hmxl10 , hmxl300 ) !--------------------------------------------------------------------------------------------------- USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: bvf ( 0 : N ) !! Brunt Vaisala frequancy [s-2] REAL ( 8 ), INTENT ( IN ) :: zr ( 1 : N ) !! depth at cell center [m] REAL ( 8 ), INTENT ( IN ) :: rhoc10 !! thermal expension coefficient [kg m-3] REAL ( 8 ), INTENT ( IN ) :: rhoc300 !! thermal expension coefficient [kg m-3] REAL ( 8 ), INTENT ( OUT ) :: hmxl10 !! mixed layer depth [m] REAL ( 8 ), INTENT ( OUT ) :: hmxl300 !! mixed layer depth [m] ! local variables integer :: k real ( 8 ) :: cff_new , cff_old , bvf_c , kstart ! find 10m depth kstart = N do while ( zr ( kstart ) > - 1 0. ) kstart = kstart - 1. enddo ! bvf_c = rhoc10 * ( grav / rho0 ) ! hmxl10 = zr ( kstart ) ! initialize at the near bottom value cff_old = 0. ! outer : DO k = kstart , 2 , - 1 cff_new = cff_old + MAX ( bvf ( k - 1 ), 0. ) * ( zr ( k ) - zr ( k - 1 )) ! !IF(zr(k)<=-150.0 .AND. .not. found_150m) THEN !print*,'Int_10m_150m = ',cff_new !  found_150m = .true. !ENDIF ! IF ( cff_new >= bvf_c ) THEN !hmxl = zr(k-1); exit outer hmxl10 = (( cff_new - bvf_c ) * zr ( k ) + ( bvf_c - cff_old ) * zr ( k - 1 )) / ( cff_new - cff_old ) exit outer ENDIF cff_old = cff_new ENDDO outer ! find 150m depth kstart = N do while ( zr ( kstart ) > - 29 5. ) kstart = kstart - 1. enddo ! bvf_c = rhoc300 * ( grav / rho0 ) ! hmxl300 = zr ( kstart ) ! initialize at the near bottom value cff_old = 0. outer2 : DO k = kstart , 2 , - 1 cff_new = cff_old + MAX ( bvf ( k - 1 ), 0. ) * ( zr ( k ) - zr ( k - 1 )) IF ( cff_new >= bvf_c ) THEN !hmxl = zr(k-1); exit outer hmxl300 = (( cff_new - bvf_c ) * zr ( k ) + ( bvf_c - cff_old ) * zr ( k - 1 )) / ( cff_new - cff_old ) exit outer2 ENDIF cff_old = cff_new ENDDO outer2 ! !--------------------------------------------------------------------------------------------------- END SUBROUTINE compute_mxl !=================================================================================================== !=================================================================================================== SUBROUTINE compute_mxl2 ( bvf , rhoc , zr , zref , N , hmxl ) !--------------------------------------------------------------------------------------------------- USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: bvf ( 0 : N ) !! Brunt Vaisala frequancy [s-2] REAL ( 8 ), INTENT ( IN ) :: zr ( 1 : N ) !! depth at cell center [m] REAL ( 8 ), INTENT ( IN ) :: rhoc !! thermal expension coefficient [kg m-3] REAL ( 8 ), INTENT ( IN ) :: zref REAL ( 8 ), INTENT ( OUT ) :: hmxl !! mixed layer depth [m] ! local variables integer :: k real ( 8 ) :: cff_new , cff_old , bvf_c , kstart ! find 300m depth kstart = N do while ( zr ( kstart ) > zref ) kstart = kstart - 1. enddo ! bvf_c = rhoc * ( grav / rho0 ) ! hmxl = zr ( kstart ) ! initialize at the near bottom value cff_old = 0. ! outer : DO k = kstart , 2 , - 1 cff_new = cff_old + MAX ( bvf ( k - 1 ), 0. ) * ( zr ( k ) - zr ( k - 1 )) ! IF ( cff_new >= bvf_c ) THEN hmxl = (( cff_new - bvf_c ) * zr ( k ) + ( bvf_c - cff_old ) * zr ( k - 1 )) / ( cff_new - cff_old ) exit outer ENDIF cff_old = cff_new ENDDO outer !--------------------------------------------------------------------------------------------------- END SUBROUTINE compute_mxl2 !=================================================================================================== !=================================================================================================== SUBROUTINE rho_eos_lin ( temp , salt , zr , alpha , beta , N , rho , bvf ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE rho_eos_lin  ***                           <br /> !! ** Purposes : Compute density anomaly and Brunt Vaisala frequency via linear !!                                                  Equation Of State (EOS) <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: temp ( 1 : N ) !! temperature [C] REAL ( 8 ), INTENT ( IN ) :: salt ( 1 : N ) !! salinity [psu] REAL ( 8 ), INTENT ( IN ) :: zr ( 1 : N ) !! depth at cell centers [m] REAL ( 8 ), INTENT ( IN ) :: alpha !! thermal expension coefficient [C-1] REAL ( 8 ), INTENT ( IN ) :: beta !! haline expension coefficient [psu-1] REAL ( 8 ), INTENT ( OUT ) :: bvf ( 0 : N ) !! Brunt Vaisala frequancy [s-2] REAL ( 8 ), INTENT ( OUT ) :: rho ( 1 : N ) !! density anomaly [kg/m3] ! local variables integer :: k real ( 8 ) :: cff !--------------------------------------------------------------------------------------------------- !------- DO k = 1 , N rho ( k ) = rho0 * ( 1. - alpha * ( temp ( k ) - 2. ) + beta * ( salt ( k ) - 3 5. ) ) !!    \\rho_{k} = \\rho_0 \\left( 1 - \\alpha (\\theta - 2) + \\beta (S - 35)   \\right)    <br /> ENDDO !---- DO k = 1 , N - 1 cff = 1. / ( zr ( k + 1 ) - zr ( k )) bvf ( k ) = - cff * ( grav / rho0 ) * ( rho ( k + 1 ) - rho ( k )) !!     (N&#94;2)_{k+1/2} = - \\frac{g}{\\rho_0}  \\frac{ \\rho_{k+1}-\\rho_{k} }{\\Delta z_{k+1/2}}  ENDDO bvf ( 0 ) = 0. bvf ( N ) = bvf ( N - 1 ) !--------------------------------------------------------------------------------------------------- END SUBROUTINE rho_eos_lin !=================================================================================================== !=================================================================================================== SUBROUTINE rho_eos ( temp , salt , zr , zw , N , rho , bvf ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE rho_eos  ***                           <br /> !! ** Purposes : Compute density anomaly and Brunt Vaisala frequency via nonlinear !!                                                  Equation Of State (EOS) <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: temp ( 1 : N ) !! temperature [C] REAL ( 8 ), INTENT ( IN ) :: salt ( 1 : N ) !! salinity [psu] REAL ( 8 ), INTENT ( IN ) :: zr ( 1 : N ) !! depth at cell centers [m] REAL ( 8 ), INTENT ( IN ) :: zw ( 0 : N ) !! depth at cell interfaces [m] REAL ( 8 ), INTENT ( OUT ) :: bvf ( 0 : N ) !! Brunt Vaisala frequancy [s-2] REAL ( 8 ), INTENT ( OUT ) :: rho ( 1 : N ) !! density anomaly [kg/m3] ! local variables integer :: k real ( 8 ) :: cff , cff1 , dr00 , dpth real ( 8 ) :: Tt , Ts , sqrtTs , K0 , K1 , K2 real ( 8 ) :: rho1 ( 1 : N ), K_up ( 1 : N ), K_dw ( 1 : N ) ! EOS parameters real ( 8 ) :: r00 , r01 , r02 , r03 , r04 , r05 real ( 8 ) :: r10 , r11 , r12 , r13 , r14 , r20 real ( 8 ) :: rS0 , rS1 , rS2 real ( 8 ) :: K00 , K01 , K02 , K03 , K04 real ( 8 ) :: K10 , K11 , K12 , K13 real ( 8 ) :: KS0 , KS1 , KS2 real ( 8 ) :: B00 , B01 , B02 , B03 , B10 , B11 , B12 , BS1 real ( 8 ) :: E00 , E01 , E02 , E10 , E11 , E12 !--------------------------------------------------------------------------- parameter ( r00 = 99 9.842594 , r01 = 6.793952E-2 , r02 =- 9.095290E-3 , & r03 = 1.001685E-4 , r04 =- 1.120083E-6 , r05 = 6.536332E-9 ) ! parameter ( r10 = 0.824493 , r11 =- 4.08990E-3 , r12 = 7.64380E-5 , & r13 =- 8.24670E-7 , r14 = 5.38750E-9 , r20 = 4.8314E-4 ) parameter ( rS0 =- 5.72466E-3 , rS1 = 1.02270E-4 , rS2 =- 1.65460E-6 ) ! parameter ( K00 = 1909 2.56 , K01 = 20 9.8925 , K02 =- 3.041638 , & K03 =- 1.852732e-3 , K04 =- 1.361629e-5 ) parameter ( K10 = 10 4.4077 , K11 =- 6.500517 , K12 = 0.1553190 , & K13 = 2.326469e-4 ) ! parameter ( KS0 =- 5.587545 , KS1 =+ 0.7390729 , KS2 =- 1.909078e-2 ) ! parameter ( B00 = 0.4721788 , B01 = 0.01028859 , B02 =- 2.512549e-4 , & B03 =- 5.939910e-7 , B10 =- 0.01571896 , B11 =- 2.598241e-4 , & B12 = 7.267926e-6 , BS1 = 2.042967e-3 ) ! parameter ( E00 =+ 1.045941e-5 , E01 =- 5.782165e-10 , E02 =+ 1.296821e-7 , & E10 =- 2.595994e-7 , E11 =- 1.248266e-9 , E12 =- 3.508914e-9 ) !--------------------------------------------------------------------------- dr00 = r00 - rho0 ! Compute density anomaly via Equation Of State (EOS) for seawater DO k = 1 , N Tt = temp ( k ) Ts = salt ( k ) sqrtTs = sqrt ( Ts ) ! rho1 ( k ) = ( dr00 + Tt * ( r01 + Tt * ( r02 + Tt * ( r03 + Tt * ( r04 + Tt * r05 )))) & + Ts * ( r10 + Tt * ( r11 + Tt * ( r12 + Tt * ( r13 + Tt * r14 ))) & + sqrtTs * ( rS0 + Tt * ( rS1 + Tt * rS2 )) + Ts * r20 ) & ) ! K0 = Tt * ( K01 + Tt * ( K02 + Tt * ( K03 + Tt * K04 ))) & + Ts * ( K10 + Tt * ( K11 + Tt * ( K12 + Tt * K13 )) & + sqrtTs * ( KS0 + Tt * ( KS1 + Tt * KS2 )) ) ! K1 = B00 + Tt * ( B01 + Tt * ( B02 + Tt * B03 )) + Ts * ( B10 + Tt * ( B11 + Tt * B12 ) + sqrtTs * BS1 ) ! K2 = E00 + Tt * ( E01 + Tt * E02 ) + Ts * ( E10 + Tt * ( E11 + Tt * E12 )) ! dpth = - zr ( k ) cff = K00 - 0.1 * dpth cff1 = K0 + dpth * ( K1 + K2 * dpth ) rho ( k ) = ( rho1 ( k ) * cff * ( K00 + cff1 ) - 0.1 * dpth * rho0 * cff1 ) / ( cff * ( cff + cff1 )) ! For bvf computation dpth = 0. - zw ( k ) K_up ( k ) = K0 + dpth * ( K1 + K2 * dpth ) dpth = 0. - zw ( k - 1 ) K_dw ( k ) = K0 + dpth * ( K1 + K2 * dpth ) ENDDO cff = grav / rho0 DO k = 1 , N - 1 cff1 = 0.1 * ( 0. - zw ( k )) bvf ( k ) =- cff * ( ( rho1 ( k + 1 ) - rho1 ( k )) * ( K00 + K_dw ( k + 1 )) * ( K00 + K_up ( k )) & - cff1 * ( rho0 * ( K_dw ( k + 1 ) - K_up ( k )) + K00 * ( rho1 ( k + 1 ) - rho1 ( k )) & + rho1 ( k + 1 ) * K_dw ( k + 1 ) - rho1 ( k ) * K_up ( k ) & ) ) / ( ( K00 + K_dw ( k + 1 ) - cff1 ) * ( K00 + K_up ( k ) - cff1 ) & * ( zr ( k + 1 ) - zr ( k )) ) ENDDO bvf ( 0 ) = 0. bvf ( N ) = 0. !--------------------------------------------------------------------------------------------------- END SUBROUTINE rho_eos !=================================================================================================== !=================================================================================================== SUBROUTINE rho_eos2 ( temp , salt , zr , N , rho ) !--------------------------------------------------------------------------------------------------- !!==========================================================================<br /> !!                  ***  ROUTINE rho_eos  ***                           <br /> !! ** Purposes : Compute density anomaly and Brunt Vaisala frequency via nonlinear !!                                                  Equation Of State (EOS) <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: temp ( 1 : N ) !! temperature [C] REAL ( 8 ), INTENT ( IN ) :: salt ( 1 : N ) !! salinity [psu] REAL ( 8 ), INTENT ( IN ) :: zr ( 1 : N ) !! depth at cell centers [m] REAL ( 8 ), INTENT ( OUT ) :: rho ( 1 : N ) !! density anomaly [kg/m3] ! local variables integer :: k real ( 8 ) :: cff , cff1 , dr00 , dpth real ( 8 ) :: Tt , Ts , sqrtTs , K0 , K1 , K2 real ( 8 ) :: rho1 ( 1 : N ), K_up ( 1 : N ), K_dw ( 1 : N ) ! EOS parameters real ( 8 ) :: r00 , r01 , r02 , r03 , r04 , r05 real ( 8 ) :: r10 , r11 , r12 , r13 , r14 , r20 real ( 8 ) :: rS0 , rS1 , rS2 real ( 8 ) :: K00 , K01 , K02 , K03 , K04 real ( 8 ) :: K10 , K11 , K12 , K13 real ( 8 ) :: KS0 , KS1 , KS2 real ( 8 ) :: B00 , B01 , B02 , B03 , B10 , B11 , B12 , BS1 real ( 8 ) :: E00 , E01 , E02 , E10 , E11 , E12 !--------------------------------------------------------------------------- parameter ( r00 = 99 9.842594 , r01 = 6.793952E-2 , r02 =- 9.095290E-3 , & r03 = 1.001685E-4 , r04 =- 1.120083E-6 , r05 = 6.536332E-9 ) ! parameter ( r10 = 0.824493 , r11 =- 4.08990E-3 , r12 = 7.64380E-5 , & r13 =- 8.24670E-7 , r14 = 5.38750E-9 , r20 = 4.8314E-4 ) parameter ( rS0 =- 5.72466E-3 , rS1 = 1.02270E-4 , rS2 =- 1.65460E-6 ) ! parameter ( K00 = 1909 2.56 , K01 = 20 9.8925 , K02 =- 3.041638 , & K03 =- 1.852732e-3 , K04 =- 1.361629e-5 ) parameter ( K10 = 10 4.4077 , K11 =- 6.500517 , K12 = 0.1553190 , & K13 = 2.326469e-4 ) ! parameter ( KS0 =- 5.587545 , KS1 =+ 0.7390729 , KS2 =- 1.909078e-2 ) ! parameter ( B00 = 0.4721788 , B01 = 0.01028859 , B02 =- 2.512549e-4 , & B03 =- 5.939910e-7 , B10 =- 0.01571896 , B11 =- 2.598241e-4 , & B12 = 7.267926e-6 , BS1 = 2.042967e-3 ) ! parameter ( E00 =+ 1.045941e-5 , E01 =- 5.782165e-10 , E02 =+ 1.296821e-7 , & E10 =- 2.595994e-7 , E11 =- 1.248266e-9 , E12 =- 3.508914e-9 ) !--------------------------------------------------------------------------- dr00 = r00 - rho0 ! Compute density anomaly via Equation Of State (EOS) for seawater DO k = 1 , N Tt = temp ( k ) Ts = salt ( k ) sqrtTs = sqrt ( Ts ) ! rho1 ( k ) = ( dr00 + Tt * ( r01 + Tt * ( r02 + Tt * ( r03 + Tt * ( r04 + Tt * r05 )))) & + Ts * ( r10 + Tt * ( r11 + Tt * ( r12 + Tt * ( r13 + Tt * r14 ))) & + sqrtTs * ( rS0 + Tt * ( rS1 + Tt * rS2 )) + Ts * r20 ) & ) ! K0 = Tt * ( K01 + Tt * ( K02 + Tt * ( K03 + Tt * K04 ))) & + Ts * ( K10 + Tt * ( K11 + Tt * ( K12 + Tt * K13 )) & + sqrtTs * ( KS0 + Tt * ( KS1 + Tt * KS2 )) ) ! K1 = B00 + Tt * ( B01 + Tt * ( B02 + Tt * B03 )) + Ts * ( B10 + Tt * ( B11 + Tt * B12 ) + sqrtTs * BS1 ) ! K2 = E00 + Tt * ( E01 + Tt * E02 ) + Ts * ( E10 + Tt * ( E11 + Tt * E12 )) ! dpth = - zr ( k ) cff = K00 - 0.1 * dpth cff1 = K0 + dpth * ( K1 + K2 * dpth ) rho ( k ) = ( rho1 ( k ) * cff * ( K00 + cff1 ) - 0.1 * dpth * rho0 * cff1 ) / ( cff * ( cff + cff1 )) ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE rho_eos2 !=================================================================================================== !=================================================================================================== SUBROUTINE tridiag_solve ( N , Hz , Ak , Fmass , r_D , f , dt ) !--------------------------------------------------------------------------------------------------- !!============================================================================<br /> !!                  ***  ROUTINE tridiag_solve  ***                           <br /> !! ** Purposes : solve the tridiagonal problem associated with the implicit !!                         in time treatment of vertical diffusion/viscosity  <br /> !!============================================================================<br /> IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: dt !! time-step [s] REAL ( 8 ), INTENT ( IN ) :: Ak ( 0 : N ) !! eddy diffusivity/viscosity [m2/s] REAL ( 8 ), INTENT ( IN ) :: Fmass ( 0 : N ) !! mass flux (in case of an implicit treatment of MF terms) [m/s] REAL ( 8 ), INTENT ( IN ) :: r_D !! bottom friction multiplied by bottom velocity (not used yet) [m/s] REAL ( 8 ), INTENT ( INOUT ) :: f ( 1 : N ) !! (in: right-hand side) (out:solution of tridiagonal problem) ! local variables INTEGER :: k REAL ( 8 ) :: a ( 1 : N ), b ( 1 : N ), c ( 1 : N ), q ( 1 : N ) REAL ( 8 ) :: difA , difC , advA , advB , advC , cff ! DO k = 2 , N - 1 difA = - 2. * dt * Ak ( k - 1 ) / ( Hz ( k - 1 ) + Hz ( k )) difC = - 2. * dt * Ak ( k ) / ( Hz ( k + 1 ) + Hz ( k )) advA = - dt * Hz ( k ) * Fmass ( k - 1 ) / ( Hz ( k ) + Hz ( k - 1 )) advC = - dt * Hz ( k ) * Fmass ( k ) / ( Hz ( k ) + Hz ( k + 1 )) advB = dt * Hz ( k + 1 ) * Fmass ( k ) / ( Hz ( k ) + Hz ( k + 1 )) & - dt * Hz ( k - 1 ) * Fmass ( k - 1 ) / ( Hz ( k ) + Hz ( k - 1 )) a ( k ) = difA + advA c ( k ) = difC - advC b ( k ) = Hz ( k ) - difA - difC + advB ENDDO !++ Bottom BC a ( 1 ) = 0. difC = - 2. * dt * Ak ( 1 ) / ( Hz ( 2 ) + Hz ( 1 ) ) - dt * r_D advC = - dt * Hz ( 1 ) * Fmass ( 1 ) / ( Hz ( 1 ) + Hz ( 2 )) advB = dt * Hz ( 2 ) * Fmass ( 1 ) / ( Hz ( 1 ) + Hz ( 2 )) c ( 1 ) = difC - advC b ( 1 ) = Hz ( 1 ) - difC + advB !++ Surface BC difA = - 2. * dt * Ak ( N - 1 ) / ( Hz ( N - 1 ) + Hz ( N )) advA = - dt * Hz ( N ) * Fmass ( N - 1 ) / ( Hz ( N ) + Hz ( N - 1 )) advB = - dt * Hz ( N - 1 ) * Fmass ( N - 1 ) / ( Hz ( N ) + Hz ( N - 1 )) a ( N ) = difA + advA c ( N ) = 0. b ( N ) = Hz ( N ) - difA + advB ! cff = 1. / b ( 1 ) q ( 1 ) = - c ( 1 ) * cff f ( 1 ) = f ( 1 ) * cff DO k = 2 , N cff = 1. / ( b ( k ) + a ( k ) * q ( k - 1 )) q ( k ) = - cff * c ( k ) f ( k ) = cff * ( f ( k ) - a ( k ) * f ( k - 1 ) ) ENDDO DO k = N - 1 , 1 , - 1 f ( k ) = f ( k ) + q ( k ) * f ( k + 1 ) ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE tridiag_solve !=================================================================================================== ! END MODULE scm_oce","tags":"","loc":"sourcefile/scm_oce.f90.html"},{"title":"scm_tke.f90 – SCM-EDMF ocean","text":"Source Code MODULE scm_tke !!============================================================================<br /> !!                       ***  MODULE  scm_tke  ***                            <br /> !! Eddy-diffusion closure: TKE scheme with diagnostic mixing lengths !!                         adapted from NEMO TKE turbulent closure model      <br /> !!============================================================================<br /> !!----------------------------------------------------------------------------<br /> !!   compute_tke_bdy   : top and bottom boundary conditions for TKE           <br /> !!   compute_shear     : compute shear production term                        <br /> !!   advance_tke       : tke time stepping: advance tke at next time step     <br /> !!   compute_mxl       : compute mixing length scale                          <br /> !!   compute_ED        : compute avm and avt                                  <br /> !!   tridiag_solve_tke : tridiagonal solver for TKE equation                  <br /> !!----------------------------------------------------------------------------<br /> IMPLICIT NONE CONTAINS SUBROUTINE compute_tke_bdy ( taux , tauy , tke_const , tke_sfc , tke_bot , flux_sfc ) !!==========================================================================<br /> !!                  ***  ROUTINE compute_tke_bdy  ***                       <br /> !! ** Purposes : compute top and bottom boundary conditions for TKE equation<br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE REAL ( 8 ), INTENT ( IN ) :: taux !! zonal surface stress      [m2/s2] REAL ( 8 ), INTENT ( IN ) :: tauy !! meridional surface stress [m2/s2] !    REAL(8), INTENT(IN   )         :: Bsfc         !! surface buoyancy flux     [m2/s3] INTEGER , INTENT ( IN ) :: tke_const !! choice of TKE constants REAL ( 8 ), INTENT ( OUT ) :: tke_sfc !! surface value for Dirichlet condition [m2/s2] REAL ( 8 ), INTENT ( OUT ) :: tke_bot !! bottom value for Dirichlet condition [m2/s2] REAL ( 8 ), INTENT ( OUT ) :: flux_sfc !! surface TKE flux for Neumann condition [m3/s3] !local variables REAL ( 8 ) :: wstar2 , ustar2 , cff ! velocity scales !wstar2   =  ( -1. * MIN(Bsfc,0.) )**(2./3.) ustar2 = SQRT ( taux ** 2 + tauy ** 2 ) ! IF ( ustar2 == 0. ) THEN !! free convection case (  {\\rm tke\\_sfc\\_dirichlet = True}   ) : tke_sfc = 0.0001 !!  k_{\\rm sfc} = 1.5 \\times 10&#94;{-3}\\;{\\rm m}&#94;2\\;{\\rm s}&#94;{-2} <br /> flux_sfc = 0. ELSE !! wind_cooling case (  {\\rm tke\\_sfc\\_dirichlet = False}   ) :   F_{\\rm sfc}&#94;k = \\left.  K_e \\partial_z k \\right|_{\\rm sfc} = 0\\;{\\rm m}&#94;3\\;{\\rm s}&#94;{-3}     <br /> IF ( tke_const == 0 ) THEN cff = 1. / SQRT ( cm_nemo * ceps_nemo ) ELSE IF ( tke_const == 1 ) THEN cff = 1. / SQRT ( cm_mnh * ceps_mnh ) ELSE cff = 1. / SQRT ( cm_r81 * ceps_r81 ) ENDIF !tke_sfc  = cff*ustar2 tke_sfc = 6 7.83 * ustar2 flux_sfc = 0. !2.*67.83*ustar2*SQRT(ustar2) ENDIF ! bottom boundary condition tke_bot = tke_min !! bottom boundary condition :  k_{\\rm bot} = k_{\\rm min}   !----------------------------------------------------------------------------- END SUBROUTINE compute_tke_bdy !============================================================================= SUBROUTINE compute_shear ( u_n , v_n , u_np1 , v_np1 , Akv , zr , N , shear2 ) !!==========================================================================<br /> !!                  ***  ROUTINE compute_shear  ***                         <br /> !! ** Purposes : compute shear production term for TKE equation             <br /> !!==========================================================================<br /> IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: u_n ( 1 : N ), v_n ( 1 : N ) !! velocity components at time n    [m/s] REAL ( 8 ), INTENT ( IN ) :: u_np1 ( 1 : N ), v_np1 ( 1 : N ) !! velocity components at time n+1  [m/s] REAL ( 8 ), INTENT ( IN ) :: zr ( 1 : N ) !! depth at cell centers [m] REAL ( 8 ), INTENT ( IN ) :: Akv ( 0 : N ) !! eddy-viscosity [m2/s] REAL ( 8 ), INTENT ( OUT ) :: shear2 ( 0 : N ) !! shear production term [m2/s3] ! local variables INTEGER :: k REAL ( 8 ) :: du , dv , cff shear2 ( 0 : N ) = 0. DO k = 1 , N - 1 cff = Akv ( k ) / ( zr ( k + 1 ) - zr ( k ) ) ** 2 du = cff * ( u_n ( k + 1 ) - u_n ( k ) ) * 0.5 * ( u_n ( k + 1 ) + u_np1 ( k + 1 ) - u_n ( k ) - u_np1 ( k ) ) !! Shear production term using discretization from Burchard (2002) <br /> !!  {\\rm Sh}_{k+1/2} = \\frac{ (K_m)_{k+1/2} }{ \\Delta z_{k+1/2}&#94;2 } ( u_{k+1}&#94;n - u_{k}&#94;n ) ( u_{k+1}&#94;{n+1/2} - u_{k}&#94;{n+1/2} )   dv = cff * ( v_n ( k + 1 ) - v_n ( k ) ) * 0.5 * ( v_n ( k + 1 ) + v_np1 ( k + 1 ) - v_n ( k ) - v_np1 ( k ) ) shear2 ( k ) = du + dv ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE compute_shear !=================================================================================================== ! SUBROUTINE advance_tke ( tke_n , lup , ldwn , Akv , Akt , Hz , zr , bvf , buoyMF , shear2 , & shear2MF , trpl_corrMF , wtke , dt , tke_sfc , tke_bot , flux_sfc , & dirichlet_bdy_sfc , tke_const , N , tke_np1 , pdlr , eps , residual ) !!==========================================================================<br /> !!                  ***  ROUTINE advance_tke  ***                           <br /> !! ** Purposes : tke time stepping, advance tke from time step n to n+1     <br /> !!==========================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: dt !! time-step [s] REAL ( 8 ), INTENT ( IN ) :: tke_sfc !! surface boundary condition for TKE [m2/s2] REAL ( 8 ), INTENT ( IN ) :: tke_bot !! bottom boundary condition for TKE [m2/s2] REAL ( 8 ), INTENT ( IN ) :: flux_sfc !! surface TKE flux [m3/s3] REAL ( 8 ), INTENT ( IN ) :: tke_n ( 0 : N ) !! TKE at time n    [m2/s2] REAL ( 8 ), INTENT ( IN ) :: lup ( 0 : N ) !! upward mixing length [m] REAL ( 8 ), INTENT ( IN ) :: ldwn ( 0 : N ) !! downward mixing length [m] REAL ( 8 ), INTENT ( IN ) :: Akt ( 0 : N ) !! eddy-diffusion [m2/s] REAL ( 8 ), INTENT ( IN ) :: bvf ( 0 : N ) !! Brunt Vaisala frequency [s-2] REAL ( 8 ), INTENT ( IN ) :: shear2 ( 0 : N ) !! shear tke production term [m2/s3] REAL ( 8 ), INTENT ( IN ) :: Akv ( 0 : N ) !! eddy-viscosity [m2/s] REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: zr ( 1 : N ) !! depth at cell centers [m] REAL ( 8 ), INTENT ( IN ) :: buoyMF ( 0 : N ) !! TKE buoyancy forcing term associated with mass flux [m2/s3] REAL ( 8 ), INTENT ( IN ) :: shear2MF ( 0 : N ) !! TKE shear forcing term associated with mass flux [m2/s3] REAL ( 8 ), INTENT ( IN ) :: trpl_corrMF ( 0 : N ) !! Contribution of mass flux to d(w'e)/dz term [m2/s3] INTEGER , INTENT ( IN ) :: tke_const !! choice of TKE constants LOGICAL , INTENT ( IN ) :: dirichlet_bdy_sfc !! Nature of the TKE surface boundary condition (T:dirichlet,F:Neumann) REAL ( 8 ), INTENT ( INOUT ) :: wtke ( 1 : N ) !! Diagnostics : w'e term  [m3/s3] REAL ( 8 ), INTENT ( OUT ) :: tke_np1 ( 0 : N ) !! TKE at time n+1    [m2/s2] REAL ( 8 ), INTENT ( OUT ) :: pdlr ( 0 : N ) !! inverse of turbulent Prandtl number REAL ( 8 ), INTENT ( OUT ) :: eps ( 0 : N ) !! TKE dissipation term [m2/s3] REAL ( 8 ), INTENT ( OUT ) :: residual !! Diagnostics : TKE spuriously added to guarantee that tke >= tke_min [m3/s3] ! local variables INTEGER :: k REAL ( 8 ) :: mxld ( 0 : N ), mxlm ( 0 : N ), ff ( 0 : N ), cff , Ric , isch REAL ( 8 ) :: sh2 , buoy , Ri , cff1 , cff2 , cff3 , rhs , rhsmin , ceps , ct , cm ! Initialization tke_np1 ( N ) = tke_min IF ( dirichlet_bdy_sfc ) tke_np1 ( N ) = tke_sfc ! tke_np1 ( 0 ) = tke_bot tke_np1 ( 1 : N - 1 ) = tke_min ! Initialize constants IF ( tke_const == 0 ) THEN ceps = ceps_nemo ; Ric = Ric_nemo ; isch = ce_nemo / cm_nemo ELSE IF ( tke_const == 1 ) THEN cm = cm_mnh ; ct = ct_mnh ; ceps = ceps_mnh Ric = Ric_mnh ; isch = ce_mnh / cm_mnh ELSE cm = cm_r81 ; ct = ct_r81 ; ceps = ceps_r81 Ric = Ric_r81 ; isch = ce_r81 / cm_r81 ENDIF ! DO k = 1 , N - 1 mxld ( k ) = SQRT ( lup ( k ) * ldwn ( k ) ) !! Dissipative mixing length :  (l_\\epsilon)_{k+1/2} = \\sqrt{ l_{\\rm up} l_{\\rm dwn} }     <br /> mxlm ( k ) = MIN ( lup ( k ), ldwn ( k ) ) ENDDO !==================================================================== pdlr (:) = 0. !! Inverse Prandtl number function of Richardson number <br /> !IF(tke_const==0) THEN DO k = 1 , N - 1 sh2 = shear2 ( k ) ! shear2 is already multiplied by Akv buoy = bvf ( k ) Ri = MAX ( buoy , 0. ) * Akv ( k ) / ( sh2 + bshear ) !!  {\\rm Ri}_{k+1/2} = (K_m)_{k+1/2} (N&#94;2)_{k+1/2} / {\\rm Sh}_{k+1/2}  <br /> pdlr ( k ) = MAX ( pdlrmin , Ric / MAX ( Ric , Ri ) ) !!  ({\\rm Pr}_t)&#94;{-1}_{k+1/2} = \\max\\left( {\\rm Pr}_{\\min}&#94;{-1} , \\frac{{\\rm Ri}_c}{ \\max( {\\rm Ri}_c, {\\rm Ri}_{k+1/2}  ) } \\right)      <br /> END DO !ELSE !  DO k = 1,N-1 !    buoy    = bvf(k) !    Ri      = buoy*mxld(k)*mxlm(k)/tke_n(k)  ! Redelsperger number !    pdlr(k) = MAX( pdlrmin, ct/(cm+cm*MAX(-0.5455, Ric*Ri ) ) ) !  END DO !ENDIF !==================================================================== ! constants for TKE dissipation term cff1 = 0.5 ; cff2 = 1.5 ; cff3 = cff1 / cff2 ! eps ( 0 : N ) = 0. ff ( 0 : N ) = 0. residual = 0. ! DO k = 1 , N - 1 ! construct the right hand side rhs = shear2 ( k ) - Akt ( k ) * bvf ( k ) & + shear2MF ( k ) + buoyMF ( k ) + trpl_corrMF ( k ) !!   {\\rm rhs}_{k+1/2} = {\\rm Sh}_{k+1/2} - (K_s N&#94;2)_{k+1/2} + {\\rm Sh}_{k+1/2}&#94;{\\rm p} + (-a&#94;{\\rm p} w&#94;{\\rm p} B&#94;{\\rm p})_{k+1/2} + {\\rm TOM}_{k+1/2}    <br /> ! dissipation divided by tke eps ( k ) = cff2 * ceps * SQRT ( tke_n ( k )) / mxld ( k ) ! increase rhs if too small to guarantee that tke > tke_min rhsmin = ( tke_min - tke_n ( k )) / dt & + eps ( k ) * tke_min - cff3 * eps ( k ) * tke_n ( k ) ! right hand side for tridiagonal problem ff ( k ) = tke_n ( k ) + dt * MAX ( rhs , rhsmin ) + dt * cff3 * eps ( k ) * tke_n ( k ) !! Right-hand-side for tridiagonal problem  f_{k+1/2} = k&#94;n_{k+1/2} + \\Delta t {\\rm rhs}_{k+1/2} + \\frac{1}{2} \\Delta t c_\\epsilon \\frac{ k&#94;n_{k+1/2} \\sqrt{k&#94;n_{k+1/2}} }{(l_\\epsilon)_{k+1/2}}   <br /> ! keep track of the energy spuriously added to get tke > tke_min IF ( rhs < rhsmin ) residual = residual + ( zr ( k + 1 ) - zr ( k )) * ( rhsmin - rhs ) ENDDO !! Boundary conditions : <br /> ff ( 0 ) = tke_bot IF ( dirichlet_bdy_sfc ) THEN !!  {\\rm dirichlet\\_bdy\\_sfc = True}\\qquad  \\rightarrow \\qquad k_{N+1/2}&#94;{n+1} = k_{\\rm sfc}    <br /> ff ( N ) = tke_sfc ELSE ff ( N ) = 2. * Hz ( N ) * flux_sfc / ( isch * ( Akv ( N ) + Akv ( N - 1 )) ) !!  {\\rm dirichlet\\_bdy\\_sfc = False}\\qquad  \\rightarrow \\qquad k_{N+1/2}&#94;{n+1} - k_{N+1/2}&#94;{n} = 2 \\frac{\\Delta z_{N} F_{\\rm sfc}&#94;k}{(K_e)_{N+1/2}+ (K_e)_{N-1/2}}    <br /> ENDIF ! CALL tridiag_solve_tke ( N , Hz , isch * Akv , zr , eps , ff , dt , dirichlet_bdy_sfc ) !! Solve the tridiagonal problem ! DO k = 0 , N tke_np1 ( k ) = MAX ( ff ( k ), tke_min ) ENDDO ! ** Diagnostics ** !         Store the TKE dissipation term for diagnostics eps ( 1 : N - 1 ) = ceps * ( cff2 * tke_np1 ( 1 : N - 1 ) - cff1 * tke_n ( 1 : N - 1 )) * ( SQRT ( tke_n ( 1 : N - 1 ) ) / mxld ( 1 : N - 1 )) eps ( 0 ) = 0. ; eps ( N ) = 0. !         Store the ED contribution to w'e turbulent flux DO k = 1 , N wtke ( k ) = wtke ( k ) - 0.5 * isch * ( akv ( k ) + akv ( k - 1 )) * ( tke_np1 ( k ) - tke_np1 ( k - 1 )) / Hz ( k ) ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE advance_tke !=================================================================================================== !=================================================================================================== SUBROUTINE compute_mxl ( tke , bvf , Hz , taux , tauy , N , lup , ldwn ) !--------------------------------------------------------------------------------------------------- !!============================================================================<br /> !!                  ***  ROUTINE compute_mxl  ***                             <br /> !! ** Purposes : compute mixing length scales                                 <br /> !!============================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: tke ( 0 : N ) !! turbulent kinetic energy [m2/s2] REAL ( 8 ), INTENT ( IN ) :: bvf ( 0 : N ) !! Brunt Vaisala frequency [s-2] REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: taux !! surface stress [m2/s2] REAL ( 8 ), INTENT ( IN ) :: tauy !! surface stress [m2/s2] REAL ( 8 ), INTENT ( OUT ) :: lup ( 0 : N ) !! upward mixing length [m] REAL ( 8 ), INTENT ( OUT ) :: ldwn ( 0 : N ) !! downward mixing length [m] ! local variables INTEGER :: k REAL ( 8 ) :: rn2 , ld80 ( 0 : N ), raug , ustar2 !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< !  Mixing length !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ustar2 = SQRT ( taux ** 2 + tauy ** 2 ) !!  u_{\\star}&#94;2 = \\sqrt{\\tau_x&#94;2 + \\tau_y&#94;2} <br /> ! lup ( 0 : N ) = mxl_min ldwn ( 0 : N ) = mxl_min ! DO k = 0 , N ! interior value : l=sqrt(2*e/n&#94;2) rn2 = MAX ( bvf ( k ) , rsmall ) ld80 ( k ) = MAX ( mxl_min , SQRT ( 2. * tke ( k ) / rn2 ) ) !! Buoyancy length scale :   (l_{\\rm up})_{k+1/2}=(l_{\\rm dwn})_{k+1/2}=(l_{D80})_{k+1/2} = \\sqrt{\\frac{2 k_{k+1/2}&#94;{n+1}}{ \\max( (N&#94;2)_{k+1/2}, (N&#94;2)_{\\min} ) }}     <br /> END DO !! Physical limits for the mixing lengths <br /> ldwn ( 0 ) = 0. DO k = 1 , N ldwn ( k ) = MIN ( ldwn ( k - 1 ) + Hz ( k ) , ld80 ( k ) ) !! Limit  (l_{\\rm dwn})_{k+1/2}  such that  \\partial_z (l_{\\rm dwn})_{k} \\le 1  the bottom boundary condition is  (l_{\\rm dwn})_{1/2} = l_{\\min}  <br /> END DO ! surface mixing length = F(stress)=vkarmn*2.e5*taum/(rho0*g) raug = vkarmn * 2.e5 / grav lup ( N ) = MAX ( mxl_min0 , raug * ustar2 ) ! surface boundary condition ! DO k = N - 1 , 0 , - 1 lup ( k ) = MIN ( lup ( k + 1 ) + Hz ( k + 1 ) , ld80 ( k ) ) !! Limit  (l_{\\rm up})_{k-1/2}  such that  - \\partial_z (l_{\\rm up})_{k} \\le 1  the surface boundary condition is  (l_{\\rm up})_{N+1/2} = \\frac{\\kappa}{g} (2 \\times 10&#94;{-5}) u_{\\star}&#94;2  <br /> END DO lup ( N ) = 0. !<-- ensures that avm(jpk) = 0. ! !--------------------------------------------------------------------------------------------------- END SUBROUTINE compute_mxl !=================================================================================================== !=================================================================================================== SUBROUTINE compute_ED ( tke , lup , ldwn , pdlr , extrap_sfc , tke_const , N , Akv , Akt ) !--------------------------------------------------------------------------------------------------- !!============================================================================<br /> !!                  ***  ROUTINE compute_ED  ***                              <br /> !! ** Purposes : compute the vertical eddy viscosity and diffusivity          <br /> !!============================================================================<br /> USE scm_par IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: tke ( 0 : N ) !! turbulent kinetic energy [m2/s2] REAL ( 8 ), INTENT ( IN ) :: pdlr ( 0 : N ) !! inverse turbulent Prandtl number REAL ( 8 ), INTENT ( IN ) :: lup ( 0 : N ) !! upward mixing length [m] REAL ( 8 ), INTENT ( IN ) :: ldwn ( 0 : N ) !! downward mixing length [m] LOGICAL , INTENT ( IN ) :: extrap_sfc !! (T) extrapolate eddy coefficients to the surface INTEGER , INTENT ( IN ) :: tke_const !! choice of TKE constants REAL ( 8 ), INTENT ( OUT ) :: Akv ( 0 : N ) !! eddy-viscosity [m2/s] REAL ( 8 ), INTENT ( OUT ) :: Akt ( 0 : N ) !! eddy-diffusivity [m2/s] ! local variables INTEGER :: k REAL ( 8 ) :: mxlm , av , cm , ct !* Initialize constants IF ( tke_const == 0 ) THEN cm = cm_nemo ELSE IF ( tke_const == 1 ) THEN cm = cm_mnh ELSE cm = cm_r81 ENDIF ! DO k = 0 , N mxlm = MIN ( lup ( k ), ldwn ( k ) ) !! Compute \"master\" mixing length  (l_m)_{k+1/2} = \\min( (l_{\\rm up})_{k+1/2}, (l_{\\rm dwn})_{k+1/2} ) <br /> av = cm * mxlm * SQRT ( tke ( k )) !! Compute eddy-viscosity  (K_m)_{k+1/2} = C_m l_m \\sqrt{k_{k+1/2}&#94;{n+1}}  <br /> Akv ( k ) = MAX ( av , avm_bak ) Akt ( k ) = MAX ( pdlr ( k ) * av , avt_bak ) !! Compute eddy-diffusivity  (K_s)_{k+1/2} = ({\\rm Pr}_t)&#94;{-1}_{k+1/2}   (K_m)_{k+1/2} <br /> END DO Akv ( N ) = 0. ; Akt ( N ) = 0. !Warning : extrapolation ignores the variations of Hz with depth IF ( extrap_sfc ) THEN Akv ( N ) = 1.5 * Akv ( N - 1 ) - 0.5 * Akv ( N - 2 ) !! if  {\\rm extrap\\_sfc = True} \\qquad \\rightarrow \\qquad (K_m)_{N+1/2} = \\frac{3}{2} (K_m)_{N-1/2} - \\frac{1}{2} (K_m)_{N-3/2}  Akt ( N ) = 1.5 * Akt ( N - 1 ) - 0.5 * Akt ( N - 2 ) ENDIF !--------------------------------------------------------------------------------------------------- END SUBROUTINE compute_ED !=================================================================================================== ! !################################################################# ! TRIDIAGONAL INVERSION !################################################################# !=================================================================================================== SUBROUTINE tridiag_solve_tke ( N , Hz , Ak , zr , eps , f , dt , dirichlet_bdy_sfc ) !--------------------------------------------------------------------------------------------------- !!============================================================================<br /> !!                  ***  ROUTINE tridiag_solve_tke  ***                       <br /> !! ** Purposes : solve the tridiagonal problem associated with the implicit !!                                         in time treatment of TKE equation  <br /> !!============================================================================<br /> IMPLICIT NONE INTEGER , INTENT ( IN ) :: N !! number of vertical levels REAL ( 8 ), INTENT ( IN ) :: dt !! time step [s] REAL ( 8 ), INTENT ( IN ) :: Hz ( 1 : N ) !! layer thickness [m] REAL ( 8 ), INTENT ( IN ) :: Ak ( 0 : N ) !! eddy-diffusivity for TKE [m2/s] REAL ( 8 ), INTENT ( IN ) :: zr ( 1 : N ) !! depth at cell centers [m] REAL ( 8 ), INTENT ( IN ) :: eps ( 0 : N ) !! TKE dissipation term divided by TKE [s-1] LOGICAL , INTENT ( IN ) :: dirichlet_bdy_sfc !! nature of the TKE boundary condition REAL ( 8 ), INTENT ( INOUT ) :: f ( 0 : N ) !! (in) rhs for tridiagonal problem (out) solution of the tridiagonal problem ! local variables INTEGER :: k REAL ( 8 ) :: a ( 0 : N ), b ( 0 : N ), c ( 0 : N ), q ( 0 : N ) REAL ( 8 ) :: difA , difC , cff ! DO k = 1 , N - 1 difA = - 0.5 * dt * ( Ak ( k - 1 ) + Ak ( k )) / ( Hz ( k ) * ( zr ( k + 1 ) - zr ( k ))) difC = - 0.5 * dt * ( Ak ( k + 1 ) + Ak ( k )) / ( Hz ( k + 1 ) * ( zr ( k + 1 ) - zr ( k ))) a ( k ) = difA c ( k ) = difC b ( k ) = 1. - difA - difC + dt * eps ( k ) ENDDO !++ Bottom BC a ( 0 ) = 0. ; b ( 0 ) = 1 ; c ( 0 ) = 0. IF ( dirichlet_bdy_sfc ) THEN a ( N ) = 0. ; b ( N ) = 1. ; c ( N ) = 0. ELSE a ( N ) = - 1. ; b ( N ) = - a ( N ); c ( N ) = 0. ENDIF ! cff = 1. / b ( 0 ) q ( 0 ) = - c ( 0 ) * cff f ( 0 ) = f ( 0 ) * cff DO k = 1 , N cff = 1. / ( b ( k ) + a ( k ) * q ( k - 1 )) q ( k ) = - cff * c ( k ) f ( k ) = cff * ( f ( k ) - a ( k ) * f ( k - 1 ) ) ENDDO DO k = N - 1 , 0 , - 1 f ( k ) = f ( k ) + q ( k ) * f ( k + 1 ) ENDDO !--------------------------------------------------------------------------------------------------- END SUBROUTINE tridiag_solve_tke !=================================================================================================== ! END MODULE scm_tke","tags":"","loc":"sourcefile/scm_tke.f90.html"},{"title":"scm_par.f90 – SCM-EDMF ocean","text":"Source Code MODULE scm_par IMPLICIT NONE PUBLIC REAL ( 8 ), PUBLIC , PARAMETER :: grav = 9.81 !! Gravity of Earth REAL ( 8 ), PUBLIC , PARAMETER :: vkarmn = 0.41 !! Von Karman constant REAL ( 8 ), PUBLIC , PARAMETER :: rho0 = 102 7. !! Boussinesq reference density [kg/m3] REAL ( 8 ), PUBLIC , PARAMETER :: cp = 398 5.0d0 !! Specific heat capacity of saltwater [J/kg K] REAL ( 8 ), PUBLIC , PARAMETER :: rpi = 4. * ATAN ( 1. ) !!  \\pi  REAL ( 8 ), PUBLIC , PARAMETER :: wpmin = 1.e-08 !! Minimum value of  w&#94;{\\rm p}  [m/s] <br /> ! !--------------------------------------------------------------------- ! SCM parameters for TKE turbulent closure <br /> !--------------------------------------------------------------------- REAL ( 8 ), PUBLIC , PARAMETER :: tke_min = 1.e-8 !! minimum TKE value [m2/s2] REAL ( 8 ), PUBLIC , PARAMETER :: tke_min0 = 1.e-4 !! surface minimum value of tke for Dirichlet condition [m2/s2] REAL ( 8 ), PUBLIC , PARAMETER :: avm_bak = 1.e-4 !! background eddy-viscosity [m2/s] REAL ( 8 ), PUBLIC , PARAMETER :: avt_bak = 1.e-5 !! background eddy-diffusivity [m2/s] ! NEMO constants REAL ( 8 ), PUBLIC , PARAMETER :: ceps_nemo = 0.5 * sqrt ( 2. ) !! Constant  c_\\epsilon  in NEMO REAL ( 8 ), PUBLIC , PARAMETER :: cm_nemo = 0.1 !! Constant  c_m  in NEMO REAL ( 8 ), PUBLIC , PARAMETER :: ct_nemo = 0.1 !! Constant  c_s  in NEMO REAL ( 8 ), PUBLIC , PARAMETER :: ce_nemo = 0.1 !! Constant  c_e  in NEMO REAL ( 8 ), PUBLIC , PARAMETER :: Ric_nemo = 2. / ( 2. + ceps_nemo / cm_nemo ) !! Critical Richardson number ! MNH constants REAL ( 8 ), PUBLIC , PARAMETER :: ceps_mnh = 0.845 !! Constant  c_\\epsilon  in MesoNH REAL ( 8 ), PUBLIC , PARAMETER :: cm_mnh = 0.126 !! Constant  c_m  in MesoNH REAL ( 8 ), PUBLIC , PARAMETER :: ct_mnh = 0.143 !! Constant  c_s  in MesoNH REAL ( 8 ), PUBLIC , PARAMETER :: ce_mnh = 0.34 !! Constant  c_e  in MesoNH REAL ( 8 ), PUBLIC , PARAMETER :: Ric_mnh = 0.143 !! Critical Richardson number ! RS81 constants REAL ( 8 ), PUBLIC , PARAMETER :: ceps_r81 = 0.7 !! Constant  c_\\epsilon  in Redelsperger & Sommeria 1981 REAL ( 8 ), PUBLIC , PARAMETER :: cm_r81 = 0.0667 !! Constant  c_m  in Redelsperger & Sommeria 1981 REAL ( 8 ), PUBLIC , PARAMETER :: ct_r81 = 0.167 !! Constant  c_s  in Redelsperger & Sommeria 1981 REAL ( 8 ), PUBLIC , PARAMETER :: ce_r81 = 0.4 !! Constant  c_e  in Redelsperger & Sommeria 1981 REAL ( 8 ), PUBLIC , PARAMETER :: Ric_r81 = 0.139 !! Critical Richardson number ! REAL ( 8 ), PUBLIC , PARAMETER :: mxl_min = ( avm_bak / 0.1 ) / sqrt ( tke_min ) !! minimum value for mixing lengths [m] REAL ( 8 ), PUBLIC , PARAMETER :: mxl_min0 = 0.04 !! minimum surface value for miwing lengths [m] REAL ( 8 ), PUBLIC , PARAMETER :: pdlrmin = 0.1 !! minimum value for the inverse Prandtl number ! REAL ( 8 ), PUBLIC , PARAMETER :: bshear = 1.e-20 !! minimum shear REAL ( 8 ), PUBLIC , PARAMETER :: rsmall = 1.e-20 ! END MODULE scm_par","tags":"","loc":"sourcefile/scm_par.f90.html"}]}